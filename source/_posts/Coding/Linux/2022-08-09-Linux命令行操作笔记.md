---
title: Linux命令行操作笔记
date: 2022-08-09 03:22:56
categories:
- Coding
- Linux
tags:
id: 16
---

> 图片需要重新转换，可以考虑分为两篇或者按章节分为多篇

## 前言 

有任何问题可以在下面的评论区留言交流

## 第一章 Linux系统简介

### 1.2 开源软件介绍

#### （1）Unix主要发行版本 

![](https://img.arctee.cn/one/202208090421952.png)

<!--more-->

#### （2）Linux发行版本比较  

1. Ubuntu 20.04LTS   18.04软件比较多

2. Manjaro

桌面环境： xfc, gnome, kde

3. LinuxMint

Ubuntu的替代，基于ubuntu发行版上的一种优化版，开行即用，区别就是驱动不同
比乌班图更为流畅

桌面：cinammon, mate, xfce

4. Deepin 

最好的中文Linux发行版之一，流畅度差

5. Pop!OS

6. Debian 、 Centos

7. Arch

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611818641980-8ba058b8-f319-4b6c-974b-28a5bf73a319.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=928234&status=done&style=none&width=1920)

#### （3）LAMP 
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611819831580-cbfbb6d4-6d29-4d1b-8b5f-0d5b3e4f6d09.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=778496&status=done&style=none&width=1920)

## 第二章 Linux系统安装

[镜像源汇总](nrzo6f)
### 2.1 VMware 虚拟机介绍
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611822806387-9ef2b770-0e37-408d-8475-e3c432ab78a2.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=897798&status=done&style=none&width=1920)

#### （1）Vmware 特点 
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611822877887-c5ca762e-2e89-42e1-8b51-69e847231a21.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=901317&status=done&style=none&width=1920)

#### （2）配置要求
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611823003442-c9336b30-5588-44b4-9c59-06a5a8f94e17.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=795102&status=done&style=none&width=1920)

### 2.2 系统分区

步骤：分区 -> 格式化（将分区表写入到磁盘中）-> 设置设备文件名（不用自己弄）-> 挂载
在 Linux 世界里，一切皆文件。

安装 CentOS6.9 系统，硬盘给20G，建议分区配置如下：

1. 系统启动区 boot : 256M
1. 虚拟内存交换区 swamp : 2000M
1. 用户家目录 home : 2000M
1. 剩余全部给 root 

## 第三章 **Linux 的目录结构 **

### 3.1 基本介绍

linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。

![](https://cdn.nlark.com/yuque/0/2021/jpeg/1730795/1612512628471-b1a4a7e2-cf01-43c8-b59c-dfb06267381b.jpeg#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1600&size=0&status=done&style=none&width=1600)

### 3.2 Linux 具体目录结构

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611910350824-4f0e9ec1-679b-4e69-8e6b-677a1fac6b4d.png#align=left&display=inline&height=525&margin=%5Bobject%20Object%5D&name=&originHeight=525&originWidth=845&size=0&status=done&style=none&width=845)
**boot、etc 目录要备份 ** 

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611910899155-37d49851-d1cb-4309-8cb2-7182cf9e9b66.png#align=left&display=inline&height=498&margin=%5Bobject%20Object%5D&name=&originHeight=498&originWidth=827&size=0&status=done&style=none&width=827)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611911102731-3e848a76-e4f3-47e9-9ba4-66d78b2953c7.png#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&name=&originHeight=488&originWidth=774&size=0&status=done&style=none&width=774)

- **/lib**
   - 系统开机所需要最基本的动态链接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。
- **/lost+found**
   - 一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
- **/etc ****[****重点****]**
   - 所有系统管理所需要的配置文件和子目录。my.conf
- **/usr**
   - 用户的很多应用程序和文件都放在这个目录下。类似于Windows下的 program files 目录
- **/bin ****[****重点****]****(usr/bin、/usr/local/bin) [****usr:****Unix System Resource，即Unix系统资源的缩写****]**
   - 是Binary的缩写，这个目录存放着经常使用的命令
- **/sbin (usr/sbin、/usr/local/sbin)**
   - s 就是 super 的意思，这里存放的是系统管理员使用的系统管理程序
- **/home ****[****重点****]**
   - 存放普通用户的主目录，在Linux中的每个用户都有一个自己的目录，一般该目录一用户的账号名命名
- **/root ****[****重点****]**
   - 该目录为系统管理员，超级权限者的用户目录
- **/boot**
   - 存放的启动Linux时使用的一些核心文件，包括一些链接文件和镜像文件
- **/proc **
   - 虚拟目录，是系统内存的映射，访问这个目录来获取系统信息。
- **/srv **
   - service 的缩写，该目录是存放一些服务启动之后需要提取的数据
- **/sys**
   - Linux2.6 内核的一个很大变化，该目录安装了2.6内核中新出现的一个文件系统
- **/tmp**
   - 存放临时文件
- **/dev**
   - 类似于 windows的设备管理器，把所有的硬件用文件的形式存储
- **/media ****[****重点****]**
   - Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后 Linux 会把识别的设备挂载到这个目录下
- **/mnt [****重点****]**
- 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 /mnt/ 上，然后进入该目录就可以查看里的内容了。d:/ myshare
- **/opt**
   - 这是给主机额外安装软件所摆放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空。
- **/usr/local ****[****重****点****]**
   - 这是另个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。
- **/var ****[****重点****]**
   - 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。
- **/selinux [security-enhanced linux] 类似 360**
   - Selinux 是一种安全子系统，它能控制程序只能访同特定文件。

### 3.3 Linux 目录总结一下

1. linux 的目录中有且只要一个根目录 / 
1. linux 的各个目录存放的内容是规划好，不用乱放文件。
1. linux 是以文件的形式管理我们的设备，因此 linux 系统，一切皆为文件。
1. linux 的各个文件目录下存放什么内容，大家必须有一个认识。
1. 学习后，你脑海中应该有一颗 linux 目录树。

## 第四章 Linux 常用命令
**
### 4.1 文件处理命令

#### （1） 命令格式与目录处理命令 ls

**命令格式 ：** 命令  [-选项]  [参数]  
例 ： ls -la  /etc 
说明：1）个别命令使用不遵循此格式
   	   2）当有多个选项时，可以写在一起
  	   3）简化选项与完整选项  -a 等于 --all
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1611912358230-bfa2cdc5-2be3-465c-a8c6-ae613f80fd53.png#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&name=&originHeight=433&originWidth=756&size=0&status=done&style=none&width=756)
**命令名称：****ls**** **
命令英文原意：list 
命令所在路径：/bin/ls 
执行权限：所有用户
功能描述：显示目录文件
语法：ls  选项[-ald]  [文件或目录] 
-a    显示所有文件，包括隐藏文件
（想要隐文件就在文件名前面加一个点 “.”）
-l     详细信息显示
-d    查看目录属性
     -h    人性化查看
-i     查看节点

tip：
-rw-r--r-- 

- - 文件类型（- 文件 d 目录 l 软链接文件）
- rw- r-- r-- 

u g o 
u所有者 g所属组 o其他人
r读 w写 x执行
#### 
#### （2） 目录处理命令

**命令名称：****mkdir**** **
命令英文原意：make directories 
命令所在路径：/bin/mkdir 
执行权限：所有用户
语法：mkdir -p  [目录名] 
功能描述：创建新目录 -p  递归创建
范例： $ mkdir -p /tmp/Japan/boduo 
 	  $ mkdir /tmp/Japan/longze /tmp/Japan/cangjing

**命令名称：****cd **
命令英文原意：change directory 
命令所在路径：shell内置
命令执行权限：所有用户
语法：cd [目录] 
功能描述：切换目录
范例： $ cd  /tmp/Japan/boduo     切换到指定目录
 	  $ cd  ..        回到上一级目录

**命令名称：pwd **
命令英文原意： print working directory 
命令所在路径：/bin/pwd 
执行权限：所有用户
语法：pwd 
功能描述：显示当前目录
范例：$ pwd 
  /tmp/Japan

**命令名称：****rmdir **
命令英文原意：remove empty directories 
命令所在路径：/bin/rmdir 
执行权限：所有用户
语法：rmdir [目录名] 
功能描述： 删除空目录
范例： $ rmdir /tmp/Japan/boduo

**命令名称：****cp**** **
命令英文原意：copy 
命令所在路径：/bin/cp 
执行权限：所有用户
语法：cp  -rp  [原文件或目录] [目标目录] 
-r  复制目录
-p  保留文件属性
功能描述：复制文件或目录
范例：$ cp  -r /tmp/Japan/cangjing  /root 
将目录/tmp/Japan/cangjing复制到目录/root下
$ cp  -rp /tmp/Japan/boduo /tmp/Japan/longze /root 
将/tmp/Japan目录下的boduo和longze目录复制到/root下，保持目录属性
$ cp -r/tmp/Japan/cangjing  /root/shenchao
将目录/tmp/apan/ cangjing复制到目录/root下并将其改名为 shenchao

**命令名称：mv**** **
命令英文原意：move 
命令所在路径：/bin/mv
执行权限：所有用户
语法：mv   [原文件或目录] [目标目录] 
功能描述：剪切文件、改名
范例：$ mv /tmp/Japan/longze  /root/nvshen 
移动文件longze到/root 目录下并改名为nvshen
$  mv cangjingkong canglaoshi
将cangjingkong重命名为canglaoshi

**命令名称：****rm **
命令英文原意：remove 
命令所在路径：/bin/rm 
执行权限：所有用户
语法：rm  -rf   [文件或目录] 
-r  删除目录
-f  强制执行
功能描述：删除文件
范例：$ rm  /tmp/yum.log 
删除文件/tmp/yum.log 
$ rm -rf  /tmp/Japan/longze 
删除目录/tmp/Japan/longze

#### （3）文件处理命令

**命令名称：****touch **
命令所在路径：/bin/touch 
执行权限：所有用户 
语法：touch  [文件名]                 
功能描述：创建空文件 
范例： $ touch Japanlovestory.list

若未指明详细的绝对路径，则默认创建在当前路径
创建文件名时如直接加入空格，系统认为创建两个文件
如需创建中间带空格文件名的文件，可加双引号。（但不建议这样命名）

**命令名称：****cat**
命令所在路径：/bin/cat 
执行权限：所有用户 
语法：cat [文件名] 
功能描述：显示文件内容            
   -n  显示行号 
范例： $ cat  /etc/issue              $ cat  -n /etc/services

彩蛋：tac（反向列示）(不支持-n)

**命令名称：****more**** **
命令所在路径：/bin/more 
执行权限：所有用户 
语法：more  [文件名]                  
   (空格) 或f       翻页               
   (Enter)             换行                 
  q或Q              退出 
功能描述：分页显示文件内容 
范例：   $ more  /etc/services

**命令名称：****less**** **
命令所在路径：/usr/bin/less 
执行权限：所有用户 
语法：less  [文件名] 
上箭头翻行 PgUp翻页
功能描述：分页显示文件内容（可向上翻页） 
范例：   $  less  /etc/services
**tips: 按下 / 后可以搜索 会反显高亮  按q退出（more也可以）**
**按 N(next) 显示下ー处高亮**

**命令名称：****head**
 命令所在路径：/usr/bin/head 
执行权限：所有用户 
语法：head  [文件名] 
功能描述：显示文件前面几行    
     -n 指定行数  （若不指定行数，默认显示前10行）
范例：   $ head -n 20 /etc/services

**命令名称：****tail **
命令所在路径：/usr/bin/tail 
执行权限：所有用户 
语法：tail  [文件名] 
功能描述：显示文件后面几行    
    -n 指定行数    
   -f  动态显示文件末尾内容 
范例：   $ tail -n 18 /etc/services

#### （4） 链接命令
**
**命令名称：****ln**** **
命令英文原意：link 
命令所在路径：/bin/ln 
执行权限：所有用户 
语法：ln  -s  [原文件]  [目标文件]                 
 -s  创建软链接 
功能描述：生成链接文件

范例：        
$ ln -s  /etc/issue  /tmp/issue.soft        
 创建文件/etc/issue的软链接/tmp/issue.soft        

$ ln  /etc/issue  /tmp/issue.hard        
 创建文件/etc/issue的硬链接/tmp/issue.hard

**软链接特征：**
类似 Windows 快捷方式 
1、lrwxrwxrwx    l 软链接 
软链接文件权限都为 rwxrwxrwx 
2、文件大小-只是符号链接 
3、/tmp/issue.soft -> /etc/issue 箭头指向原文件

**硬链接特征： **
1、拷贝cp -p + 同步更新 
echo "this is a test" >> /etc/motd 
2、可通过i节点识别 
3、不能跨分区
4、不能针对目录使用

### 4.2 权限管理命令（[详细见](https://www.jianshu.com/p/d27016653f1d)）

#### （1） 权限管理命令 chmod

**命令名称：****chmod **
命令英文原意：change the permissions mode of a file 
命令所在路径：/bin/chmod 
执行权限：所有用户 
语法：chmod  [{ugoa}{+-=}{rwx}] [文件或目录]                         
  [mode=421 ]  [文件或目录]                          
 -R  递归修改 （目录下的所有文件都改成同样的权限）
功能描述：改变文件或目录权限

权限的数字表示      
r  ---- 4      w ---- 2      x  ---- 1
rwxrw-r--    7   6    4

范例：       
 $ chmod  g+w  testfile         
赋予文件testfile所属组写权限      
  $ chmod  -R 777  testdir         
修改目录testfile及其目录下文件为所有用户具有全部权限


| 
代表字符 | 
权限 | 
对文件的含义 | 
对目录的含义 |
| --- | --- | --- | --- |
| 
r | 
读权限 | 
可以查看文件内容 | 
**可以列出目录中的内容** |
| 
w | 
写权限 | 
可以修改文件内容 | 
**可以在目录中创建、删除文件** |
| 
x | 
执行权限 | 
可以执行文件 | 
**可以进入目录** |


**tips:
**
**1.rwx 作用在文件时**
1>  r : read，可以读取，查看
2>  w : writte, 可以修改，但是不代表可以删除该文件，删除一个文件的前提是对该文件所在的目录（文件夹）具有写的权限，才能删该文件
3>  x : execute，可以被执行
**2.rwx 作用在目录时**
1> r，ls 查看目录内容
2> w,  可以修改，目录内创建+删除+重命名目录
3> x, 可以进入该目录 

#### （2） 其他权限管理命令

**命令名称：****chown **
命令英文原意：change file ownership
命令所在路径：/bin/chown 
执行权限：所有用户 
语法：chown  [用户] [文件或目录]  
功能描述：改变文件或目录的所有者 范例：$ chown  shenchao fengjie               
 改变文件fengjie的所有者为shenchao

**命令名称：****chgrp **
命令英文原意：change file group ownership 
命令所在路径：/bin/chgrp
执行权限：所有用户 
语法：chgrp  [用户组]  [文件或目录]  
功能描述：改变文件或目录的所属组
范例：$ chgrp lampbrother fengjie            
    改变文件fengjie的所属组为lampbrother

**命令名称：****umask**** **
命令英文原意：the user file-creation mask 
命令所在路径：Shell内置命令 
执行权限：所有用户 
语法：umask [-S]             
-S   以rwx形式显示新建文件缺省权限 
功能描述：显示、设置文件的缺省权限 
范例： $ umask -S
tips: 新建文件是默认没有x权限（比如：防止木马病毒攻击）
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612548554118-b26c5e6e-9b73-446f-97c0-998280e1e47e.png#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&name=&originHeight=355&originWidth=669&size=0&status=done&style=none&width=669)
### 4.3 文件搜索命令

#### （1） 文件搜索命令 find

**命令名称：****find**** **
命令所在路径：/bin/find 
执行权限：所有用户 
语法：find  [搜索范围]  [匹配条件] 
功能描述：文件搜索
范例：
$ find  /etc  -name  init           
在目录/etc中查找文件 init       
-iname 不区分大小写      
  
$ find /etc -name *init*
在目录/etc中查找文件名包含 init     

$ find /etc -name init??？ 
在目录/etc中查找文件名init开头并有3个字符的   

$ find /etc -name init*
在目录/etc中查找文件名init开头的    
_tips : * 匹配任意字符，?匹配单个字符_
_
$ find  /  -size  +204800           
在根目录下查找大于100MB的文件        
  +n  大于   -n 小于   n 等于     
（1数据块=512字节=0.5K    100MB=102400KB=204800数据块）
   
$ find  /home  -user  shenchao         
在根目录下查找所有者为shenchao的文件       
 -group  根据所属组查找

$ find  /etc  -cmin  -5         
在/etc下查找5分钟内被修改过属性的文件和目录
       -amin  访问时间 access   
       -cmin  文件属性 change     
      -mmin 文件内容 modify

$ find  /etc -size  +163840 -a -size  -204800          
在/etc下查找大于80MB小于100MB的文件          
-a 两个条件同时满足         
 -o 两个条件满足任意一个即可
        
$ find /etc -name inittab -exec ls -l {} \;         
在/etc下查找inittab文件并显示其详细信息          
-exec/-ok 命令 {} \;  对搜索结果执行操作
_tips : __-exec直接执行，ok会询问操作_
（花括号 {} 指查找的结果，斜杠 \ 表示转义符，分号 ; 表示结束）

-type 根据文件类型查找                  
f 文件    d 目录    l 软链
find /etc -name inti* -a -type f

-inum  根据i节点查找
find . -inum 31531 -exec rm {} \; 
在当前目录下查找节点为31531的文件删除

#### （2） 其他搜索命令

**命令名称：****locate **
命令所在路径：/usr/bin/locate 
执行权限：所有用户 
语法：locate  文件名 
功能描述：在文件资料库中查找文件 
范例：$ locate inittab
tips : 新建文件 locate 不到，可以 updatedb，更新文件资料库后查找【tmp 不在文件资料库内】
$  locate -i masichun.json // -i 作用你不区分大小写类似 -iname

**命令名称：****which**** **
命令所在路径：/usr/bin/which
执行权限：所有用户 
语法：which  命令 
功能描述：搜索命令所在目录及别名信息 
范例：$ which ls

**命令名称：****whereis **
命令所在路径：/usr/bin/whereis 
执行权限：所有用户 
语法：whereis  [命令名称]  
功能描述：搜索命令所在目录及帮助文档路径 
范例：$ whereis ls

**命令名称：****grep **
命令所在路径：/bin/grep 
执行权限：所有用户 
语法：grep  -iv [指定字串] [文件] 
功能描述：在文件中搜寻字串匹配的行并输出             
-i  不区分大小写             
 -v 排除指定字串 
       范例：# grep  mysql  /root/install.log
   # grep -v ^# /etc/inittab 去除以#开头的所有行信息，^表示以XXX开头 

### 4.4 帮助命令

**命令名称：****man **
命令英文原意：manual 
命令所在路径：/usr/bin/man 
执行权限：所有用户 
语法：man  [命令或配置文件] 
  (空格) 或f        翻页             
   (Enter)            换行                 
  q或Q              退出 
功能描述：获得帮助信息
范例： $ man ls                
查看ls命令的帮助信息      

(用man命令来查看配置文件的信息时，不需要man+绝对路径，只需写man+[配置文件的名字] )  
(info 跟 man 功能大同小异)

 $ man services                
查看配置文件services的帮助信息
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612514453444-4b3f63c7-d48b-47d8-9b4f-2a7d82cb5e6a.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=1670&size=0&status=done&style=none&width=1280)
1 命令的帮助  5配置文件的帮助
man 5 passwd -> 查看配置文件的帮助
( whereis passwd时，除了显示 passwd命令的绝对路径，也会显示 passwd的命令帮助路径和配文件的帮助路径，“1"代表命令帮助文件，“5"代表配置帮助文件，因此用man passwd时，要在中加上5表示查找的是 passwd的配文件帮助)

**命令名称：****whatis**
**语法：whatis ****命令**
**功能描述：获得命令的简单介绍信息**
范例：whatis ls
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612514453455-3e9594d5-56f4-4c49-910d-d5b40adb6eb2.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&originHeight=80&originWidth=862&size=0&status=done&style=none&width=862)

**类似的：apropos**
语法：apropos 配置文件
whatis 类似于精确查找
apropos 模糊查找关键字 [功能等于 man -k ][可以tab快速补全]
（如果记不清楚工具或者函数的完整名字，可以考虑用-k参数；如果仅仅想了解什么是什么，可以用f数。）

**命令名称：****help**
命令所在路径：Shell内置命令 
执行权限：所有用户 
语法：help 命令 
功能描述：获得Shell内置命令的帮助信息 
范例： $ help umask                
查看umask命令的帮助信息
（可以理解为用 which找不到命令所在路径的时候，此命令为 shell 内的命令）
(ls --help 简短的显示帮助信息，且已经翻译为了中文，如 touch --help)

### 4.5 用户管理命令
**命令名称：****useradd** 
命令所在路径：/usr/sbin/useradd 
执行权限：root 
语法：useradd 用户名 
功能描述：添加新用户 
范例： $ useradd yangmi

**命令名称：****passwd **
命令所在路径：/usr/bin/passwd 
执行权限：所有用户 
语法：passwd 用户名 
功能描述：设置用户密码
范例： $ passwd yangmi
普通用户只能更改自己密码，root用户可以更改所有人密码

**命令名称：****who **
命令所在路径：/usr/bin/who 
执行权限：所有用户 
语法：who 
功能描述：查看登录用户信息 
范例： $ who
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612514453516-80784bcc-8e50-4a5f-85e2-57fc1e2938c7.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&originHeight=244&originWidth=800&size=0&status=done&style=none&width=800)
参数分别为：
用户名  登录终端[tty本地终端/pts远程终端]  登录时间 IP地址[没有表示本地登录]

**命令名称：****w**** **
命令所在路径：/usr/bin/w 
执行权限：所有用户 
语法：w 
功能描述：查看登录用户详细信息 
范例： $ w
（命令 uptime，可以看当前系统已经运行的时司。用W命令，显示的 up 也表示当前电脑已经运行的时间。 load average后面显示的三个数，分别表示1min、5min和15min的负戴情况（cpu和内存的负载）

### 4.6 压缩解压命令
**命令名称：****gzip **
命令英文原意：GNU zip 
命令所在路径：/bin/gzip 
执行权限：所有用户 
语法：gzip [文件]  
功能描述：压缩文件 （不保留源文件）
压缩后文件格式：.gz
tips:只能压缩文件不能压缩目录

**命令名称：****gunzip****  [= gzip -d]**
命令英文原意：GNU unzip 
命令所在路径：/bin/gunzip 
执行权限：所有用户 
语法：gunzip [压缩文件] 
功能描述：解压缩 .gz 的压缩文件 （不保留源文件）
范例： $ gunzip boduo.gz


**命令名称：****tar** 
命令所在路径：/bin/tar 
执行权限：所有用户 
语法：tar  选项[-zcf] [压缩后文件名] [目录]                                   
-c    打包                 
-v    显示详细信息                 
-f     指定文件名            
-z     打包同时压缩 
功能描述：打包目录 压缩后文件格式：.tar.gz
范例：        
$ tar  -zcf   Japan.tar.gz  Japan        
将目录Japan打包并压缩为.tar.gz文件

tar命令解压缩语法：           
-x     解包           
-v    显示详细信息           
-f     指定解压文件           
-z     解压缩 
范例：$ tar  -zxvf  Japan.tar.gz

**命令名称：****zip **
命令所在路径：/usr/bin/zip 
执行权限：所有用户 
语法：     
zip  选项[-r]  [压缩后文件名]  [文件或目录]            
-r    压缩目录 
功能描述：压缩文件或目录 
压缩后文件格式：.zip
范例：
压缩文件          
$ zip  buduo.zip  boduo             
压缩目录          
$ zip  -r  Japan.zip  Japan             

tips：会保留原文件
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612550944231-b44a8ba3-cc95-408e-8f2d-ea560aff1bd1.png#align=left&display=inline&height=173&margin=%5Bobject%20Object%5D&name=&originHeight=173&originWidth=664&size=0&status=done&style=none&width=664)

**命令名称：****unzip **
命令所在路径：/usr/bin/unzip 
执行权限：所有用户 
语法：unzip  [压缩文件] 
功能描述：解压.zip的压缩文件 
范例：$ unzip test.zip

**命令名称：****bzip2 **
命令所在路径：/usr/bin/bzip2 
执行权限：所有用户 
语法： bzip2  选项 [-k] [文件]                        
           -k   产生压缩文件后保留原文件 
功能描述：压缩文件 
压缩后文件格式：.bz2 
范例：$ bzip2 -k boduo               
    $ tar -cjf  Japan.tar.bz2 Japan

**命令名称：****bunzip2** 
命令所在路径：/usr/bin/bunzip2 
执行权限：所有用户 
语法： bunzip2  选项 [-k] [压缩文件]                               
-k   解压缩后保留原文件 
功能描述：解压缩 
范例：$ bunzip2  -k boduo.bz2           
           $ tar -xjf  Japan.tar.bz2

### 4.7 网络命令

**指令名称：****write**** **
指令所在路径：/usr/bin/write 
执行权限：所有用户 
语法：write  <用户名>    
功能描述：给用户发信息，以Ctrl+D保存结束 
               （只能给在线用户发消息，若用户不在线，则发不出去）
范例：   # write linzhiling
**tips:输入错误，ctrl+backspace 删除**

**指令名称：****wall**** **
命令英文原意：write all 
指令所在路径：/usr/bin/wall 
执行权限：所有用户 
语法：wall  [message]   
功能描述：发广播信息 （用户在接收 Messages 时命令行会中断，尽量少用。）
范例：   # wall  ShenChao is a honest man!

**命令名称：****ping** 
命令所在路径：/bin/ping 
执行权限：所有用户 
语法：ping  选项  IP地址                      
   -c  指定发送次数 
功能描述：测试网络连通性 
范例：  #  ping 192.168.1.156

**命令名称：****ifconfig**** **
命令英文原意：interface configure 
命令所在路径：/sbin/ifconfig 
执行权限：root 
语法：ifconfig  网卡名称  IP地址 
功能描述：查看和设置网卡信息 
范例：# ifconfig  eth0 192.168.8.250
（eth0：本地的真实网卡按照数字依次类推   lo：回环网卡用于本机通讯试127.0.0.1）

**命令名称：****mail**** **
命令所在路径：/bin/mail 
执行权限：所有用户 
语法：mail [用户名] 
功能描述：查看发送电子邮件 
范例：# mail root
（h看邮件列表  d 1删除部件  q退出）

**命令名称：****last**** **
命令所在路径：/usr/bin/last 
执行权限：所有用户 
语法：last 
功能描述：列出目前与过去登入系统的用户信息 
范例：# last

**命令名称：****lastlog**** **
命令所在路径：/usr/bin/lastlog 
执行权限：所有用户 
语法：lastlog 
   -u 指定ID
功能描述：检查某特定用户上次登录的时间 
范例：# lastlog             
# lastlog -u 502

**命令名称：****traceroute**** **
命令所在路径：/bin/traceroute 
执行权限：所有用户 
语法：traceroute 
功能描述：显示数据包到主机间的路径 
范例：# traceroute www.lampbrother.net

**命令名称：****netstat**** **
命令所在路径：/bin/netstat 
执行权限：所有用户 
语法：netstat  [选项] 
功能描述：显示网络相关信息
选项： 
       -t ： TCP协议  
       -u： UDP协议  
  	      -l ： 监听  
-r ： 路由  
      -n ： 显示IP地址和端口号 
范例：  
#  netstat -tlun  查看本机监听的端口 
#  netstat -an  查看本机所有的网络连接  
#  netstat -rn  查看本机路由表

查看某一端口是否被占用：netstat -tunlp | grep 2181

**命令名称：****se****tup**** **
命令所在路径：/usr/bin/setup 
执行权限：root 
语法：setup 
功能描述：配置网络 
范例：# setup
（setup是针对 redhat操作系統， centos7使用 nmtui 命令）
（setup相比 ifconfig 配置网络是永久生效的）
（配置完成后要 service network restart）

**命令名称：****mount**** **
命令位置：/bin/mount 
执行权限：所有用户 
命令语法：mount [-t 文件系统] 设备文件名 挂载点 
范例：# mount -t iso9660 /dev/sr0 /mnt/cdrom
（首先创建挂载目录：mk /mnt/cdrom，然后将设备文件名 /dev/sr0 与目录相连接）
（1、t 和 iso9660 这两个参数可以路，系统默认。2、 umount：取消挂载）

### 4.8 关机重启命令

#### （1） shutdown命令
 [root@localhost ~]# shutdown [选项] 时间  
选项：  -c： 取消前一个关机命令  -h： 关机  -r： 重启

#### （2）其他关机命令
[root@localhost ~]# halt 
[root@localhost ~]# poweroff 
[root@localhost ~]# init 0

#### （3） 其他重启命令 
[root@localhost ~]# reboot  
[root@localhost ~]# init 6

#### （4） 系统运行级别
0   关机 
1  单用户 （类似于Windows的安全模式）
2  不完全多用户，不含NFS服务 （NFS：用于文件共享，但不安全，不建议使用）
3  完全多用户
4  未分配 
5  图形界面
6  重启

[root@localhost ~]# cat /etc/inittab  
#修改系统默认运行级别 
id:3:initdefault: 
[root@localhost ~]# runlevel 
#查询系统运行级别

#### （5） 退出登录命令
 [root@localhost ~]# logout

## 第五章 文本编辑器 Vim

### 5.1 Vim常用操作

**Vim 简介：**
Vim是一个功能强大的全屏幕文本编辑器， 是 Linux/UNIX 上最常用的文本编辑器， 它的作用是建立、编辑、显示文本文件。 
Vim  没有菜单，只有命令。
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612551842050-0c4a9fb5-3c17-4a25-8e1a-8185324313bf.png#align=left&display=inline&height=415&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=888&size=0&status=done&style=none&width=610)

**插入命令**

| 
命令 | 
作用 |
| --- | --- |
| 
**a** | 

在光标所在字符后插入 |
| 
**A** | 

在光标所在行尾插入 |
| 
**i** | 

在光标所在字符前插入 |
| 
**I** | 

在光标所在行行首插入 |
| 
**o** | 在光标下插入新行 |
| 
**O** | 

在光标上插入新行 |



**定位命令**

| 

命令 | 

作用 |
| --- | --- |
| :set nu
:set nonu
gg
G
nG
:n
$
0 | 设置行号
取消行号
到第一行
到最后一行
到第n行
到第n行
移至行尾
移至行首 |



**删除命令**
**命令	作用**
x	删除光标所在处字符
nx	删除光标所在处后n个字符
dd	删除光标所在行，ndd删除n行
dG 	删除光标所在行到文件末尾内容
D	删除光标所在处到行尾内容
:n1,n2d 删除指定范围的行

**复制和剪切命令**
**命令		作用**
yy		复制当前行
nyy		复制当前行以下n行
dd		剪切当前行
ndd		剪切当前行以下n行
p、P		粘贴在当前光标所在行下或行上

**：替换和取消命令**
**命令		作用**
r		取代光标所在处字符
R		从光标所在处开始替换字符，按Esc结束
u		取消上一步操作

**搜索和搜索替换命令**
**命令		作用**
/String 	搜索指定字符串; 搜索时忽略大小写：set ic
n		搜索指定字符串的下一个出现位置
:%s/old/new/g	全文替换指定字符串		tips:	%s 全文替换
:n1,n2s/old/new/g	在一定范围内替换指定字符串
起始行，终止行 s/要替换的字符串/替换的新的字符串/g
/c	询问确认

**保存和退出命令**
**命令			作用**
:w			保存修改
:w new_filename	另存为指定文件
:wq			保存修改并退出
ZZ			快捷键，保存修改并退出
:q!			不保存修改退出
:wq!			保存修改并退出（文件所有者及root可使用）

总结:
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1612551842099-325243d7-209d-46a1-96ac-389dc6114cbe.png#align=left&display=inline&height=388&margin=%5Bobject%20Object%5D&originHeight=400&originWidth=1318&size=0&status=done&style=none&width=1280)
### 
### 5.2 Vim 使用技巧

导入文件内容  :r 文件路径
查看命令路径  :!which 命令
导入命令执行结果  :r  !命令 
定义快捷键  :map  快捷键 触发命令       
范例： : map  ^P  I#                   
     : map  ^B 0x 
连续行注释   :n1,n2s/^/#/g                            
              :n1,n2s/^#//g
              :n1,n2s/^/\/\//g  	tips:\转义字符
替换  :	ab mymail [samlee@lampbrother.net](samlee@lampbrother.net)  [输入mymail会自动替换成后面的内容]
tips：定义的快捷键或者ab的内容重启后会消失。5
保存在：文件 .vimrc 中
root用户	->   /root/.vimrc
普通用户	->   /home/username/.vimrc

![](https://cdn.nlark.com/yuque/0/2021/gif/1730795/1612551842096-431eaf69-fc22-4d7c-9699-e3c3b73773e8.gif#align=left&display=inline&height=445&margin=%5Bobject%20Object%5D&originHeight=724&originWidth=1024&size=0&status=done&style=none&width=630)

## 第六章	Linux 软件安装

### 6.1 软件包管理简介

软件包分类

- 源码包 


 	脚本安装包 （install.sh）

- 二进制包（RPM包、系统默认包）


    （经过编译过后的）
源码包 
源码包的优点是： 

- 开源，如果有足够的能力，可以修改源代码 

- 可以自由选择所 需的功能 

- 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 

- 卸载方便（可以直接删除文件夹）


源码包的缺点 

- 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误

- 编译过程时间较长，安装比二进制安装时间长 

- 因为是编译安装，安装过程中一旦报错新手很难解决


RPM包 
二进制包的优点 

- 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 

- 安装速度比源码包安装快的多


二进制包缺点：

- 经过编译，不再可以看到源代码 

- 功能选择不如源码包灵活 

- 依赖性



**rpm**是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐，尤其是软件由多个rpm包组成时。
**yum**（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。

### 6.2 RPM包管理-rpm命令管理

#### （1） 软件包管理-rpm命令管理-包命名与依赖性

RPM包命名原则  
httpd-2.2.15-15.el6.centos.1.i686.rpm 
httpd   软件包名 
2.2.15  软件版本 
15   软件发布的次数 
el6.centos  适合的Linux平台 
i686   适合的硬件平台 
rpm   rpm包扩展名

RPM包依赖性 

- 树形依赖： a→b→c 

- 环形依赖： a→b→c→a 
遇到环形依赖的解决方法是把所有的RPM包放在一条命令中进行安装。
- 模块依赖： 模块依赖查询网站：[www.rpmfind.net](http://www.rpmfind.net)
库依赖的软件包名字后缀一般为.so.2，另外一种方法是用yum进行在线安装自动解决依赖问题。

#### 
#### （2） 软件包管理-rpm命令管理-安装升级与卸载

包全名与包名 

- 包全名：操作的包是没有安装的软件包时， 使用包全名。而且要注意路径

- 包名：操作已经安装的软件包时，使用包名。（由于已经安装过，所以操作包的时候不用写绝对路径）


        是搜索/var/lib/rpm/中的数据库

RPM安装 
rpm –ivh 包全名 
选项：  
-i（install）   安装   
-v（verbose） 显示详细信息     
-h（hash）  显示进度   
--nodeps  不检测依赖性

RPM包升级 
rpm  -Uvh  包全名 
选项：   
-U（upgrade）   升级

卸载 
rpm  -e  包名 
选项：   
-e（erase） 卸载   
--nodeps  不检查依赖性

（安装和升级需要加包全名，其他操作一般只加包名即可。）

#### （3） 软件包管理-rpm命令管理-查询

查询是否安装 
[root@localhost ~]# rpm  -q  包名 
_#查询包是否安装_ 
选项：  
 -q 查询（query） 

[root@localhost ~]# rpm –qa 
_#查询所有已经安装的RPM包 _
选项：   
-a 所有（all）

查询软件包详细信息 
[root@localhost ~]#  rpm –qi 包名  
选项：   
-i 查询软件信息（information）   
-p 查询未安装（需要加包全名）
包信息（package）

查询包中文件安装位置  
[root@localhost ~]#  rpm –ql 包名 
选项：   
-l 列表（list）   
-p 查询未安装包信息（package）

查询系统文件属于哪个RPM包 
[root@localhost ~]#  rpm –qf 系统文件名 
选项：  
-f 查询系统文件属于哪个软件包（file）

查询软件包的依赖性  
[root@localhost ~]# rpm –qR 包名 
选项：  
-R 查询软件包的依赖性（requires）  
-p 查询未安装包信息（package）

#### （4） 软件包管理-rpm命令管理-校验和文件提取

 RPM包校验 
[root@localhost ~]# rpm –V 已安装的包名
选项：  
-V 校验指定RPM包中的文件（verify）

验证内容中的8个信息的具体内容如下：

- S 文件大小是否改变 

- M 文件的类型或文件的权限（rwx）是否被改变 

- 5 文件MD5校验和是否改变（可以看成文件内容是否改变） 

- D 设备的中，从代码是否改变 

- L 文件路径是否改变 

- U 文件的属主（所有者）是否改变 

- G 文件的属组是否改变 

- T 文件的修改时间是否改变


文件类型 

- c 配置文件（config file） 

- d 普通文档（documentation） 

- g “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含

-  l 授权文件（license file） 

- r 描述文件（read me）


RPM包中文件提取
 [root@localhost ~]# rpm2cpio 包全名  |  \ 
cpio -idv .文件绝对路径   
（rpm2cpio 包全名  |  \ cpio -idv .文件绝对路径   中\代表命令太长，换一行写）

rpm2cpio     
_#将rpm包转换为cpio格式的命令 _
cpio        
_#是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件_

[root@localhost ~]# cpio 选项 < [文件|设备] 
选项：   
-i：copy-in模式，还原   
-d：还原时自动新建目录  
 -v：显示还原过程

[root@localhost ~]# rpm -qf /bin/ls 
#查询ls命令属于哪个软件包 

[root@localhost ~]# mv /bin/ls /tmp/ 
#造成ls命令误删除假象
[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils- 8.4-19.el6.i686.rpm | cpio -idv  ./bin/ls 
（./bin/ls 中.代表把指定文件写到当前目录中  centos7路径要使用./usr/bin/ls）

#提取RPM包中ls命令到当前目录的/bin/ls下 
[root@localhost ~]# cp /root/bin/ls  /bin/ 
#把ls命令复制会/bin/目录，修复文件丢失

### 6.3 RPM包管理-yum在线管理

#### （1） IP地址配置和网络yum源
**
1、IP地址配置 
[root@localhost ~]# setup 
#使用setup工具 
_**tips:CentOS7中是 **__**nmtui **__**命令**_

 [root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0 
把**ONBOOT=“no” **改为
  ** ONBOOT=“yes“ **
#启动网卡  

[root@localhost ~]# service network restart 
#重启网络服务

2、网络yum源 
[root@localhost yum.repos.d]# vi /etc/yum.repos.d
（cd /etc/yum.repos.d/进入目录  ls查看）

/CentOS-Base.repo 

- [base]  容器名称，一定要放在[]中 

- name  容器说明，可以自己随便写 

- mirrorlist 镜像站点，这个可以注释掉 

- baseurl 我们的yum源服务器的地址。默认是CentOS官方的yum源服务  器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址 

- enabled 此容器是否生效，如果不写或写成enable=1都是生效，写成  enable=0就是不生效

- gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效 

- gpgkey 数字证书的公钥文件保存位置。不用修改


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613377941462-8f6c5b58-1a4d-4b77-88da-35cbdf4d098a.png#align=left&display=inline&height=254&margin=%5Bobject%20Object%5D&originHeight=276&originWidth=1392&size=0&status=done&style=none&width=1280)

##### **（2） yum命令**
**
1.常用yum命令 
**1）查询 **
[root@localhost yum.repos.d]# yum list 
#查询所有可用软件包列表  
[root@localhost yum.repos.d]# yum search 关键字 
#搜索服务器上所有和关键字相关的包

**2）安装 **
[root@localhost yum.repos.d]# yum –y install 包名 
选项：  install 安装  
-y  自动回答yes

**3）升级**
[root@localhost yum.repos.d]# yum -y update 包名 
选项：  update 升级  
-y  自动回答yes

**4）卸载 **
[root@localhost yum.repos.d]# yum -y remove 包名 
选项：   remove  卸载  
-y  自动回答y e s

tips:update 不加包名全部升级（包括Linux内核，会导致服务器挂掉）
卸载同理（尽量不要卸载）

2、YUM软件组管理命令 
[root@localhost~]# yum grouplist
#列出所有可用的软件组列表  

[root@localhost~]# yum groupinstall  软件组名 
#安装指定软件组，组名可以由grouplist查询出来 

[root@localhost~]# yum groupremove  软件组名 
#卸载指定软件组

tips:安装软件包组 有空格 用""括起来
双引号


#### （2） 光盘yum源搭建

光盘yum源搭建步骤 
1）挂载光盘 
[root@localhost ~]# mount /dev/cdrom  /mnt/cdrom/  
2）让网络yum源文件失效 （视频内改名处理）
[root@localhost ~]# cd /etc/yum.repos.d/ 

[root@localhost yum.repos.d]# mv CentOS-Base.repo  \ CentOS-Base.repo.bak 

[root@localhost yum.repos.d]# mv CentOS-Debuginfo.repo \  CentOS-Debuginfo.repo.bak 

[root@localhost yum.repos.d]# mv CentOS-Vault.repo  \ CentOS-Vault.repo.bak

3）修改光盘yum源文件 
[root@localhost yum.repos.d]# vim CentOS-Media.repo 
[c6-media] 
name=CentOS-$releasever - Media 
baseurl=file:///mnt/cdrom 
#地址为你自己的光盘挂载地址 

#        file:///media/cdrom/
#        file:///media/cdrecorder/ 
#注释这两个不存在的地址 （ 不注释也没事，但是会显示报错）

gpgcheck=1 
**enabled=1 **
#把enabled=0改为enabled=1，让这个yum源配置文件生效 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

Linux系统中挂载和使用光盘的基本步骤
参考：[https://www.cnblogs.com/fengfangbing/p/6889757.html](https://www.cnblogs.com/fengfangbing/p/6889757.html)
**1. 创建挂载点**
```
mkdir /mnt/cdrom
```
在 /mnt 目录下创建一个空文件夹cdrom作为光盘的挂载点（任何一个空目录都可以作为挂载点）。
**2. 打开光驱，放入光盘**
如果用的是VMware中的虚拟机，进入虚拟机设置，选择“CD/DVD”硬件，勾选“已连接”和“启动时连接”，在连接处，选择“使用ISO映像文件”，浏览选择本地电脑中下载好的ISO光盘镜像文件，确定即可。
**3. 执行挂载命令**
```
mount -t iso9660 /dev/sr0 /mnt/cdrom
或者
mount /dev/sr0 /mnt/cdrom
```
iso9660 是光盘的默认文件系统。
由于linux系统可以自动识别光盘的文件系统，故“-t iso9660”也可以省略不写。
光盘的设备文件名是固定的，一般为/dev/cdrom或/dev/sr0。
挂载成功后，就可以通过挂载点读取光盘里面的数据。
**4. 查看光盘中的数据**
```
cd /mnt/cdrom
ls -l
```
注意：操作完成之后，如果要取出光盘，必须解除挂载。
**5. 解除挂载**
不能在挂载点目录下解除挂载，必须先切换到其他目录（如用户家目录）。
```
cd 
切换到用户家目录

umount /dev/sr0
或者 
umount /mnt/cdrom
```
### 
### 6.4 源码包管理

#### （1） 源码包和RPM包的区别

1. 区别 

- 安装之前的区别：概念上的区别 

- 安装之后的区别：安装位置不同


2. RPM包安装位置 

- 是安装在默认位置中


| 
** |  |
| --- | --- |
| 
/etc/  | 
配置文件安装目录  |
| 
/usr/bin/ | 
可执行的命令安装目录  |
| 
/usr/lib/ | 
程序所使用的函数库保存位置 |
| 
/usr/share/doc/ | 
基本的软件使用手册保存位置 |
| 
/usr/share/man/ | 
帮助文件保存位置 |


3. 源码包安装位置 

- 安装在指定位置当中，一般是  


/usr/local/软件名/

4. 安装位置不同带来的影响 

- RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是： 
   - /etc/rc.d/init.d/httpd start 

   - service httpd start

- 而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如： 

   - /usr/local/apache2/bin/apachectl start

#### （2） 源码包安装过程

1. 安装准备

- 安装C语言编译器

- 下载源码包      [http://mirror.bit.edu.cn/apache/httpd/](http://mirror.bit.edu.cn/apache/httpd/)


2. 安装注意事项 

- 源代码保存位置：/usr/local/src/ 

- 软件安装位置：/usr/local/ 

- 如何确定安装过程报错： 
   - 安装过程停止

   - 并出现error、warning或no的提示

3. 源码包安装过程 

- 下载源码包 

- 解压缩下载的源码包 

- 进入解压缩目录
（可以使用du命令查看目录大小du -sh 目录名）

- ./configure  软件配置与检查 
   - 定义需要的功能选项。 

   - 检测系统环境是否符合安装要求。

   - 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑

- make 编译 

- make  clean 

- make install    编译安装

4. 源码包的卸载 

- 不需要卸载命令，直接删除安装目录即可。


不会遗留任何垃圾文件。

### 6.5 脚本安装包

1. 脚本安装包 

- 脚本安装包并不是独立的软件包类型，常见安装的是源码包。 

- 是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。 

- 非常类似于Windows下软件的安装方式。


2. Webmin的作用 

- Webmin 是一个基于 Web 的 Linux 系统管理界面。您就可以通过图形化的方式设置用户帐号、Apache、DNS、文件共享等服务。


3. Webmin安装过程 

- 下载软件 
   - [http://sourceforge.net/projects/webadmin/files/webmin/](http://sourceforge.net/projects/webadmin/files/webmin/) 

- 解压缩，并进入加压缩目录

- 执行安装脚本


没有安装perl的需要先安装perl
安装步骤：

- 通过浏览器打开 [http://www.perl.org/get.html](http://www.perl.org/get.html)。


_(_ [](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[[https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)_  密码:hh1x__)_

- 下载适用于 Unix/Linux 的源码包。

- 下载 **perl-5.x.y.tar.gz** 文件后执行以下操作。
```
$ tar -xzf perl-5.x.y.tar.gz
$ cd perl-5.x.y
$ ./Configure -de
$ make
$ make test
$ make install
```
接下来我们如果 **perl -v** 命令查看是否安装成功。
安装成功后，Perl 的安装路径为 _/usr/local/bin_ ，库安装在 _/usr/local/lib/perlXX_, XX 为版本号。


1.941版本(202-01-05发布)
下载地址: 
 [](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)[[https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)](https://pan.baidu.com/s/1tenkC16krTUv1dwMzJQl2Q)
  密码:hh1x

ip:10000 访问
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613377941468-e07ec1df-14c7-4283-8c1e-9238c2cc860a.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=596&originWidth=888&size=0&status=done&style=none&width=242)
出现上面情况可能是

未关闭：
```
$ systemctl stop firewalld
```

参考：
**1.启动防火墙**
systemctl start firewalld
**2.禁用防火墙**
systemctl stop firewalld
**3.查看状态**
systemctl status firewalld或者 firewall-cmd --state
([https://blog.csdn.net/root_miss/article/details/83000159](https://blog.csdn.net/root_miss/article/details/83000159))
([https://blog.csdn.net/baidu_36124158/article/details/90603496](https://blog.csdn.net/baidu_36124158/article/details/90603496))

## 第七章 用户和用户组管理

### 7.1、用户配置文件

#### (1) 用户信息文件/etc/passwd

1. 用户管理简介 

- 所以越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。 

- 在Linux中主要是通过用户配置文件来查看和修改用户信息


2. /etc/passwd 

- 第1字段：用户名称

- 第2字段：密码标志 

- 第3字段：UID（用户ID） 
   - 0：   超级用户 

   - 1-499：  系统用户（伪用户）

   - 500-65535： 普通用户(centos7 从1000开始计算)

- 第4字段：GID（用户初始组ID）[不推荐修改初始组]

- 第5字段：用户说明 

- 第6字段：家目录 
   - 普通用户：/home/用户名/ 

   - 超级用户：/root/ 

- 第7字段：登录之后的Shell


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471145-391eb695-820e-4e51-aac4-7b58693b4d39.png#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=668&size=0&status=done&style=none&width=571)
3、初始组和附加组 

- 初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。 

- 附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。


4、Shell是什么 

- Shell就是Linux的命令解释器。 

- 在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin，/usr/bin/passwd等。


tips:暂时禁用用户，可以把/bin/bash -> /bin/nologin
#### (2) 影子文件/etc/shadow

1. 影子文件/etc/shadow 

- 第1字段：用户名 

- 第2字段：加密密码 
   - 加密算法升级为SHA512散列加密算法 

   - 如果密码位是“!!”或“*”代表没有密码，不能登录 

- 第3字段：密码最后一次修改日期 
   - 使用1970年1月1日作为标准时间，每过一天时间戳加1

- 第4字段：两次密码的修改间隔时间（和第3字段相比） 

- 第5字段：密码有效期（和第3字段相比） 

- 第6字段：密码修改到期前的警告天数（和第5字段相比）

- 第7字段：密码过期后的宽限天数（和第5 字段相比） 
   - 0：代表密码过期后立即失效

   - -1：则代表密码永远不会失效。 

- 第8字段：账号失效时间 
   - 要用时间戳表示 

- 第9字段：保留


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471144-ab52ab49-a798-4d65-96c3-5fbf86999a80.png#align=left&display=inline&height=644&margin=%5Bobject%20Object%5D&originHeight=914&originWidth=1818&size=0&status=done&style=none&width=1280)

2. 时间戳换算 

- 把时间戳换算为日期 
   - date -d "1970-01-01 16066 days" 

- 把日期换算为时间戳 
   - echo $(($(date --date="2014/01/06" +%s)/86400+1))


#### (3) 组信息文件/etc/group和组密码文件 /etc/gshadow

1. 组信息文件/etc/group 

- 第一字段：组名 

- 第二字段：组密码标志 

- 第三字段：GID 

- 第四字段：组中附加用户


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471173-9761cc83-b462-4ec8-9695-2d7c2037ddf0.png#align=left&display=inline&height=86&margin=%5Bobject%20Object%5D&originHeight=86&originWidth=482&size=0&status=done&style=none&width=482)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471199-a4f722da-069f-4237-a085-6516658b4890.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&originHeight=54&originWidth=318&size=0&status=done&style=none&width=318)

2. 组密码文件/etc/gshadow 

- 第一字段：组名 

- 第二字段：组密码 (不推荐使用，可以理解为给组设置个小组长)

- 第三字段：组管理员用户名 

- 第四字段：组中附加用户

### 7.2、用户管理相关文件

1. 用户的家目录 

- 普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700 

- 超级用户：/root/，所有者和所属组都是root用户，权限是550 

2. 用户的邮箱 

- /var/spool/mail/用户名/ 

3. 用户模板目录 

- /etc/skel/


### 7.3、用户管理命令
#### (1) 用户添加命令useradd
1、useradd命令格式 
[root@localhost ~]#useradd [选项] 用户名 
选项：  
-u UID： 手工指定用户的UID号  
-d 家目录： 手工指定用户的家目录  
-c 用户说明： 手工指定用户的说明  
-g 组名： 手工指定用户的初始组  
-G 组名： 指定用户的附加组  
-s shell： 手工指定用户的登录shell。默认是/bin/bash  
2、添加默认用户 

- [root@localhost ~]# useradd lamp 
   - [root@localhost ~]# grep "lamp" /etc/passwd l

   - [root@localhost ~]# grep "lamp" /etc/shadow 

   - [root@localhost ~]# grep "lamp" /etc/group 

   - [root@localhost ~]# grep "lamp" /etc/gshadow 

   - [root@localhost ~]# ll -d /home/lamp/ 

   - [root@localhost ~]# ll /var/spool/mail/lamp


3、指定选项添加用户 

- groupadd lamp1 

- useradd -u 550 -g lamp1 -G root -d /home/lamp1  \  -c "test user" -s /bin/bash lamp1

4. 用户默认值文件 

- /etc/default/useradd 
   - GROUP=100  #用户默认组 

   - HOME=/home #用户家目录 

   - INACTIVE=-1 #密码过期宽限天数（7）

   - EXPIRE=  #密码失效时间（8） 

   - SHELL=/bin/bash #默认shell 

   - SKEL=/etc/skel #模板目录 

   - CREATE_MAIL_SPOOL=yes #是否建立邮箱 


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471262-afbbd670-0257-461c-bd98-0bdde4d4f26a.png#align=left&display=inline&height=392&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=672&size=0&status=done&style=none&width=672)

- /etc/login.defs  

- PASS_MAX_DAYS 99999 #密码有效期（5） 

- PASS_MIN_DAYS 0 #密码修改间隔（4）

- PASS_MIN_LEN 5 #密码最小5位（PAM）

- PASS_WARN_AGE 7 #密码到期警告（6）

- UID_MIN  500 #最小和最大UID范围 

- GID_MAX  60000 

- ENCRYPT_METHOD SHA512 #加密模式


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614607471312-dac2aba2-1940-4fbc-8449-3d40a501286a.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&originHeight=238&originWidth=492&size=0&status=done&style=none&width=492)
#### (2) 修改用户密码passwd

1. passwd命令格式 


[root@localhost ~]#passwd [选项] 用户名 
选项：  
-S  查询用户密码的密码状态。仅root用户可用。 
-l  暂时锁定用户。仅root用户可用  
-u  解锁用户。仅root用户可用  
--stdin 可以通过管道符输出的数据作为用户的密码。 

2. 查看密码状态 


[root@localhost ~]# passwd -S lamp  
lamp PS 2013-01-06 0 99999 7 -1  
#用户名 密码设定时间（2013-01-06） 密码修改间隔时间（0） #密码有效期（99999 ） 警告时间（7） 密码不失效（-1）

3. 锁定用户和解锁用户 

- [root@localhost ~]# passwd -l lamp 

- [root@localhost ~]# passwd -u lamp   

4. 使用字符串作为用户的密码 

- [root@localhost ~]# echo "123" | passwd --stdin lamp（shell脚本可能会用到）


**tips:以下命令也可修改用户密码:**
```
echo “新密码” | passwd --stdin 用户名
#这种方式虽然简单，但是通过history命令可以查到用户的密码，所以不安全。
```

#### (3) 修改用户信息usermod&修改用户密码状态chage
1、修改用户信息usermod
[root@localhost ~]#usermod [选项] 用户名
选项：
	-u UID：		修改用户的UID号
	-c 用户说明：	修改用户的说明信息
	-G 组名：		修改用户的附加组
	-L：		临时锁定用户（Lock）
	-U：		解锁用户锁定（Unlock）

- [root@localhost ~]# usermod -c "test user" lamp


修改用户的说明

- [root@localhost ~]# usermod -G root lamp


把lamp用户加入root组

- [root@localhost ~]# usermod -L lamp


锁定用户

- [root@localhost ~]# usermod -U lamp


解锁用户

2、修改用户密码状态chage
[root@localhost ~]#chage [选项] 用户名
选项：
	-l：		列出用户的详细密码状态
	-d 日期：	修改密码最后一次更改日期（shadow3字段）
  -m 天数：  两次密码修改间隔（4字段）
	-M 天数：	密码有效期（5字段）
	-W 天数：	密码过期前警告天数（6字段）
	-I 天数：	密码过后宽限天数（7字段）
	-E 日期：	账号失效时间（8字段）


- [root@localhost ~]# chage -d 0 lamp  


这个命令其实是把密码修改日期归0了（shadow第3字段）#这样用户一登陆就要修改密码
#### (4) 删除用户userdel   用户切换命令su

1. 删除用户userdel 


[root@localhost ~]# userdel [-r] 用户名 
选项：  
-r 删除用户的同时删除用户家目录  

**手工删除用户** 

- [root@localhost ~]# vi /etc/passwd 

- [root@localhost ~]# vi /etc/shadow 

- [root@localhost ~]# vi /etc/group 

- [root@localhost ~]# vi /etc/gshadow 

- [root@localhost ~]# rm -rf /var/spool/mail/lamp 

- [root@localhost ~]# rm -rf /home/lamp/


2. 查看用户ID 


[root@localhost ~]# id 用户名

3. 切换用户身份su 


[root@localhost ~]# su [选项] 用户名 
选项：  
-  ： 选项只使用“-”代表连带用户的环境变量一起切换  (env命令查看当前环境变量)
-c 命令： 仅执行一次命令，而不切换用户身份  

- [lamp@localhost ~]$ su  –  root 


#切换成root  

- [lamp@localhost ~]$ su - root -c "useradd user3" 


#不切换成root，但是执行useradd命令添加user1用户
### 7.4、用户组管理命令
1、添加用户组
[root@localhost ~]# groupadd [选项] 组名 
选项：
-g GID 	指定组ID
2、修改用户组
[root@localhost ~]# groupmod [选项] 组名 
选项：
-g GID 	修改组ID
-n 新组名	修改组名
例：[root@localhost ~]# groupmod -n yxlm lol
#把组名lol修改为yxlm

3、删除用户组
[root@localhost ~]# groupdel [选项] 组名 
tips:删除组的时候，组内不允许有初始用户存在。
```
$ groupadd lol
$ useradd -g lol timo
$ useradd -G lol yasuo
因为timo是初始组是lol。删除lol会导致timo没有初始组。所以不可删。需要先删除用户。
而yasuo是附加组。可删。
```

4. 把用户添加入组或从组中删除


[root@localhost ~]# groupdel [选项] 组名 
选项：
-a 用户名： 把用户加入组
-d 用户名： 把用户从组中删除
## 第八章 权限管理
### 8.1 ACL权限
##### **8.1.1 ACL权限简介与开启**
参考博文：[http://c.biancheng.net/view/863.html](http://c.biancheng.net/view/863.html)

**ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。**

1、ACL权限简介
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556335-bb0d6d32-9514-48cf-8238-828adc887369.png#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=958&size=0&status=done&style=none&width=958)
2、查看分区ACL权限是否开启 
[root@localhost ~]# dumpe2fs -h /dev/sda3 
#dumpe2fs命令是查询指定分区详细文件系统信息的命令 
选项：  -h 仅显示超级块中信息，而不显示磁盘块组的详细信息
tips:先用	df -h命令查看信息，我的根是在/dev/mapper/centos-root![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556397-c0c287c2-63e7-4e05-a2fb-2c11ff4511b5.png#align=left&display=inline&height=334&margin=%5Bobject%20Object%5D&originHeight=334&originWidth=892&size=0&status=done&style=none&width=892)
CentOS7不支持这个命令,用了 xfs_info也看不懂，希望大神指点
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556431-67d96fa0-774c-4955-b633-179488bf3f62.png#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=1070&size=0&status=done&style=none&width=1070)
同样问题blog：[https://www.cnblogs.com/gaoyuechen/p/8594204.html](https://www.cnblogs.com/gaoyuechen/p/8594204.html)

3、临时开启分区ACL权限 
[root@localhost ~]# mount -o remount,acl / 
#重新挂载根分区，并挂载加入acl权限  

5. 永久开启分区ACL权限 


[root@localhost ~]# vi /etc/fstab 
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2  /   ext4    defaults,acl        1  1
#加入acl  
[root@localhost ~]# mount -o remount / 
#重新挂载文件系统或重启动系统，使修改生效

##### **8.1.2 查看与设定ACL权限**

1. 查看ACL命令 


[root@localhost ~]# getfacl 文件名 
#查看acl权限

2. 设定ACL权限的命令


[root@localhost ~]# setfacl 选项 文件名 
选项：
-m  设定ACL权限  
-x  删除指定的ACL权限  
-b  删除所有的ACL权限  
-d  设定默认ACL权限。 
-k  删除默认ACL权限  
-R  递归设定ACL权限。
3、给用户设定ACL权限
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556496-a11b3a2f-e155-41e7-abab-38086c859153.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=916&size=0&status=done&style=none&width=916)
[root@localhost ~]# useradd zhangsan 
[root@localhost ~]# useradd lisi 
[root@localhost ~]# useradd st 
[root@localhost ~]# groupadd tgroup
[root@localhost ~]# mkdir /project 
[root@localhost ~]# chown root:tgroup /project/ 
[root@localhost ~]# chmod 770 /project/ 
[root@localhost ~]# setfacl -m u:st:rx /project/ 
#给用户st赋予r-x权限，使用“u:用户名:权限”格式
4、给用户组设定ACL权限 
[root@localhost /]# groupadd tgroup2 
[root@localhost /]# setfacl -m g:tgroup2:rwx project/ 

#为组tgroup2分配ACl权限。使用“g:组名:权限”格式
```
[root@local1 ~]# mkdir /lol
[root@local1 ~]# useradd jie
[root@local1 ~]# useradd gailun
[root@local1 ~]# groupadd zuan
[root@local1 ~]# gpasswd -a jie zuan
正在将用户“jie”加入到“zuan”组中
[root@local1 ~]# gpasswd -a gailun zuan
正在将用户“gailun”加入到“zuan”组中
[root@local1 ~]# chown root:zuan /lol
[root@local1 ~]# chmod 770 /lol/
[root@local1 ~]# useradd luban
[root@local1 ~]# passwd luban
更改用户 luban 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@local1 ~]# setfacl -m u:luban:rx /lol/
[root@local1 ~]# groupadd wzry 
[root@local1 ~]# setfacl -m g:wzry:rwx /lol/
```

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556519-b5d97fe5-bfe6-41f6-a2b2-9827a27ca94f.png#align=left&display=inline&height=610&margin=%5Bobject%20Object%5D&originHeight=610&originWidth=656&size=0&status=done&style=none&width=656)
操作前后显示内容对比:
```
# ========前===========
[yasuo@local1 ~]$ getfacl /lol
getfacl: Removing leading '/' from absolute path names
# file: lol
# owner: root
# group: root
user::rwx
group::r-x
other::r-x

[yasuo@local1 ~]$ ll -d /lol
drwxr-xr-x. 2 root root 6 4月   1 15:55 /lol

# =========后===========
[yasuo@local1 ~]$ getfacl /lol
getfacl: Removing leading '/' from absolute path names
# file: lol
# owner: root
# group: zuan
user::rwx
#下面这行变化
user:luban:r-x
group::rwx
#下面这行变化
group:wzry:rwx
mask::rwx
other::---

# . -> + 表示有acl权限
[yasuo@local1 ~]$ ll -d /lol  
drwxrwx---+ 2 root zuan 6 4月   1 15:55 /lol
```
##### **8.1.3 最大有效权限与删除ACL权限**

1. 最大有效权限mask 

- mask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限



| 
** | 
** | 
** |
| --- | --- | --- |
| 
r | 
r | 
r |
| 
r | 
- | 
- |
| 
- | 
r | 
- |
| 
- | 
- | 
- |



修改最大有效权限 
[root@localhost /]# setfacl -m m:rx 文件名 
#设定mask权限为r-x。使用“m:权限”格式  

2. 删除ACL权限 [root@localhost /]# setfacl -x u:用户名 文件名 


#删除指定用户的ACL权限  

[root@localhost /]# setfacl -x g:组名 文件名 
#删除指定用户组的ACL权限

[root@localhost /]# setfacl -b 文件名 
#会删除文件的所有的ACL权限

##### **8.1.4 默认ACL权限和递归ACL权限**

1. 递归ACL权限 

- 递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。 

- setfacl -m u:用户名:权限 -R 文件名    


**tips:只对当前现有目录有作用 ，例如新touch的文件没有设定的权限。**

2. 默认ACL权限 

- 默认ACL权限的作用是如果给父目录设定了默认ACL权限，那么父目录中所有新建的子文件(目录)都会继承父目录的ACL权限。 

- setfacl -m d:u:用户名:权限 文件名

```
$ setfacl -m -d:u:timo:rx -R /lol
```

#### **8.2 文件特殊权限**
##### **8.2.1 SetUID**

1. SetUID的功能 

- 只有可以执行的**二进制程序**才能设定SUID权限 

- 命令执行者要对该程序拥有x（执行）权限 

- 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主） 

- SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效  

- passwd命令拥有SetUID权限，所以普通可以修改自己的密码


[root@localhost ~]# ll /usr/bin/passwd  
-rw**s**r-xr-x. 1 root root 25980 2月  22 2012 /usr/bin/passwd  
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556575-017d604b-1406-416d-97e8-46d6b840fef4.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&originHeight=66&originWidth=786&size=0&status=done&style=none&width=786)

- cat命令没有SetUID权限，所以普通用户不能查看/etc/shadow文件内容 [root@localhost ~]# ll /bin/cat  -rwxr-xr-x 1 root root 47976 6月  22 2012 /bin/cat


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556627-7437a814-8990-431c-ad47-fed01f20d6fa.png#align=left&display=inline&height=524&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=924&size=0&status=done&style=none&width=924)

2. 设定SetUID的方法 

- 4代表SUID 
   - chmod 4755 文件名 

   - chmod u+s 文件名 

3. 取消SetUID的方法 

- chmod 755 文件名 

- chmod u-s 文件名

4. 危险的SetUID 

- 关键目录应严格控制写权限。比如“/”、“/usr”等 

- 用户的密码设置要严格遵守密码三原则 

- 对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限


tips:
1.新建gailun(盖伦)文件，赋予s权限
``` -rw**s**r-xr-x. 1 root root 0 4月   1 17:22 gailun
2.然后去掉s,x权限。只保留rw权限。
-rw-r--r--. 1 root root 0 4月   1 17:22 gailun
3.添加s权限（此处发现S为大写，这是报错，因为gailun文件没有x权限，对应命令执行者要对该程序拥有x（执行）权限 ）
-rwSr--r--. 1 root root 0 4月   1 17:22 gailun
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622556652-b7e14927-d771-45d8-8193-2fd2056b46d6.png#align=left&display=inline&height=1122&margin=%5Bobject%20Object%5D&originHeight=1122&originWidth=660&size=0&status=done&style=none&width=660)
##### **8.2.2 SetGID**

1. SetGID针对文件的作用

- 只有可执行的二进制程序才能设置SGID权限 

- 命令执行者要对该程序拥有x（执行）权限 

- 命令执行在执行程序的时候，组身份升级为该程序文件的属组 

- SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 


[root@localhost ~]# ll /usr/bin/locate  
-rwx--s--x 1 root slocate 35612 8月  24 2010 /usr/bin/locate   
[root@localhost ~]# ll /var/lib/mlocate/mlocate.db  
-rw-r----- 1 root slocate 1838850 1月  20 04:29 /var/lib/mlocate/mlocate.db

2. SetGID针对目录的作用 

- 普通用户必须对此目录拥有r和x权限，才能进入此目录 

- 普通用户在此目录中的有效组会变成此目录的属组 

- 若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录


[root@localhost ~]# cd /tmp/ 
[root@localhost tmp]# mkdir dtest 
[root@localhost tmp]# chmod g+s dtest 
[root@localhost tmp]# ll -d dtest/
[root@localhost tmp]# chmod 777 dtest/ 
[root@localhost tmp]# su – lamp 
[lamp@localhost ~]$ cd /tmp/dtest/ 
[lamp@localhost dtest]$ touch abc 
[lamp@localhost dtest]$ ll

3. 设定SetGID 

- 2代表SGID 
   - chmod 2755 文件名 

   - chmod g+s 文件名  

4. 取消SetGID 

- chmod 755 文件名

- chmod g-s 文件名

##### **8.3.3 Sticky BIT**

1. SBIT粘着位作用 

- 粘着位目前只对目录有效 

- 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限 

- 如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一但赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件  


tips：只用root和文件拥有者可以修改删除某文件。其他用户无法操作。

[root@localhost ~]# ll -d /tmp/ 
drwxrwxrwt. 3 root root 4096 12月 13 11:22 /tmp/

2. 设置与取消粘着位 

- 设置粘着位 
   - chmod 1755 目录名 

   - chmod o+t 目录名 

- 取消粘着位
   - chmod 777 目录名 

   - chmod o-t 目录名

#### **8.3 文件系统属性chattr权限**

1. chattr命令格式 


[root@localhost ~]# chattr [+-=] [选项] 文件或目录名  
+: 增加权限  
-: 删除权限  
=: 等于某权限  

- 选项 
   - i：如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。 

   - a：如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除


2. 查看文件系统属性 


[root@localhost ~]# lsattr 选项 文件名 
选项：  
-a  显示所有文件和目录  
-d 若目标是目录，仅列出目录本身的属 性，而不是子文件的

##### **8.4 系统命令sudo权限**

1. sudo权限 

- root把本来只能超级用户执行的命令赋予普通用户执行。 

- sudo的操作对象是系统命令 


2. sudo使用 


[root@localhost ~]# visudo 
#实际修改的是/etc/sudoers文件  

root    ALL=(ALL)       ALL 
#用户名  被管理主机的地址=（可使用的身份） 授权命令（绝对路径） 

# %wheel        ALL=(ALL)       ALL 
#%组名  被管理主机的地址=（可使用的身份） 授权命令（绝对路径）

3. 授权sc用户可以重启服务器 


[root@localhost ~]# visudo 
sc  ALL= /sbin/shutdown –r now  

4. 普通用户执行sudo赋予的命令 


[root@localhost ~]# su – sc 
[sc@localhost ~]$ sudo -l 
#查看可用的sudo命令 
[lamp@localhost ~]$ sudo /sbin/shutdown -r now 
#普通用户执行sudo赋予的命令
## 
### **第九章 文件系统管理**
#### **9.1 回顾分区和文件系统**

1. 分区类型 

- 主分区：总共最多只能分四个 

- 扩展分区：只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有四个。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用。 

- 逻辑分区：逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘Linux最多支持11个逻辑分区

2. 分区表示方法


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609037-bebd57d9-f33f-4364-a397-6c0c35005a80.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&originHeight=166&originWidth=916&size=0&status=done&style=none&width=916)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609028-a2105f0c-d22e-4fa8-976f-fb1aad9bc8b9.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=850&size=0&status=done&style=none&width=850)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609101-c7e5c33a-adea-4290-a731-2e441c18bbc8.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=924&size=0&status=done&style=none&width=924)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609145-ff94fdfd-1528-4aec-971e-b281d88c553c.png#align=left&display=inline&height=454&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=880&size=0&status=done&style=none&width=880)

3. 文件系统 

- ext2：是ext文件系统的升级版本，Red Hat Linux7.2版本以前的系统默认都是ext2 文件系统。1993年发布，最大支持16TB 的分区和最大2TB的文件（1TB=1024GB=1024*1024KB）

- ext3： ext3文件系统是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件

- ext4：它是ext3文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。EXT4 的变化可以说是翻天覆地的，比如向下兼容EXT3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。是CentOS 6.3的默认文件系统      （1EB=1024PB=1024*1024TB）

#### **9.2 文件系统常用命令**
##### **9.2.1 df命令、du命令、fsck命令和dump2fs命令**

1. 文件系统查看命令df 


[root@localhost ~]# df  [选项] [挂载点] 
选项：  
-a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs  
-h 使用习惯单位显示容量，如KB，MB或GB等  
-T 显示文件系统类型  
-m 以MB为单位显示容量  
-k 以KB为单位显示容量。默认就是以KB为单位
  

2. 统计目录或文件大小 


[root@localhost ~]# du [选项] [目录或文件名] 
选项：  
-a 显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量  
-h 使用习惯单位显示磁盘占用量，如KB，MB  或GB等  
-s 统计总占用量，而不列出子目录和子文件的 占用量

**du命令和df命令的区别 **

- df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间） 

- du命令是面向文件的，只会计算文件或目录占用的空间 


3. 文件系统修复命令fsck [root@localhost ~]# fsck [选项] 分区设备文件名 选项：  -a： 不用显示用户提示，自动修复文件系统  -y： 自动修复。和-a作用一致，不过有些文件系统只支 持-y


4. 显示磁盘状态命令dumpe2fs 


[root@localhost ~]# dumpe2fs 分区设备文件名
dumpe2fs命令为ext文件系统家族的命令，我的系统为CentOS7，文件系统为**XFS**，**XFS**默认支持ACL。可以使用 xfs_info  /dev/xxx查看'XFS`文件系统信息。

##### **9.2.2 挂载命令**

1. 查询与自动挂载 


[root@localhost ~]# mount [-l] 
#查询系统中已经挂载的设备，-l会显示卷标名称  

[root@localhost ~]# mount –a 
#依据配置文件/etc/fstab的内容，自动挂载  

2. 挂载命令格式 


[root@localhost ~]# mount [-t 文件系统] [-L 卷标名]  \ 
[-o 特殊选项]   设备文件名 挂载点 
选项：  
-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统   
-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载  
-o 特殊选项：可以指定挂载的额外选项
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609202-446f4f3d-b2b6-408d-8185-ad1e05993ed2.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&originHeight=686&originWidth=1100&size=0&status=done&style=none&width=630)
home下使用noexec权限那么即使是root用户也无法执行

[root@localhost ~]# mount -o remount,noexec /home 
#重新挂载/boot分区，并使用noexec权限 
[root@localhost sh]# cd /home 
[root@localhost boot]# vi hello.sh 
[root@localhost boot]# chmod 755 hello.sh  
[root@localhost boot]# ./hello.sh 
[root@localhost boot]# mount -o remount,exec /home 
#记得改回来啊，要不会影响系统启动的

##### **9.2.3 挂载光盘与U盘**

1. 挂载光盘 


[root@localhost ~]# mkdir /mnt/cdrom/ 
#建立挂载点 
[root@localhost ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/ 
#挂载光盘 
[root@localhost ~]# mount /dev/sr0 /mnt/cdrom/   

2. 卸载命令 


[root@localhost ~]# umount 设备文件名或挂载点  
[root@localhost ~]# umount /mnt/cdrom

3. 挂载U盘 


[root@localhost ~]# fdisk –l 
#查看U盘设备文件名 

[root@localhost ~]# mount -t vfat /dev/sdb1 /mnt/usb/  
注意：Linux默认是不支持NTFS文件系统的 
##### **9.2.4 支持NTFS文件系统**

1. 下载NTFS-3G插件 


[http://www.tuxera.com/community/ntfs-3g-](http://www.tuxera.com/community/ntfs-3g-) download/ 

2. 安装NTFS-3G 


[root@localhost ~]# tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz 
#解压 
[root@localhost ~]# cd ntfs-3g_ntfsprogs-2013.1.13 
#进入解压目录 
[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# ./configure 
#编译器准备。没有指定安装目录，安装到默认位置中 
[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make 
#编译 
[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make install 
#编译安装

3. 使用 [root@localhost ~]# mount -t ntfs-3g 分区设备文件名  挂载点


#### **9.3 fdisk分区**
**（本节没看只是ppt内容照搬过来）**
##### **9.3.1 fdisk命令分区过程**
1、添加新硬盘
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609231-5abfa94d-8db9-4423-940a-c383bd6e6b9e.png#align=left&display=inline&height=484&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=552&size=0&status=done&style=none&width=552)

2、查看新硬盘 
[root@localhost ~]# fdisk -l  

3、使用fdisk命令分区 
[root@localhost ~]# fdisk /dev/sdb
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614622609286-eac8477b-ee7f-44c4-8aa0-0e41fddfd894.png#align=left&display=inline&height=572&margin=%5Bobject%20Object%5D&originHeight=572&originWidth=912&size=0&status=done&style=none&width=912)

4. 重新读取分区表信息 


[root@localhost ~]# partprobe  

5. 格式化分区 


[root@localhost ~]# mkfs -t ext4 /dev/sdb1  

6. 建立挂载点并挂载 


[root@localhost ~]# mkdir /disk1 
[root@localhost ~]# mount /dev/sdb1 /disk1/

##### **9.3.2 分区自动挂载与fstab文件修复**

1. /etc/fstab文件 

- 第一字段：分区设备文件名或UUID（硬盘通用唯一识别码） 

- 第二字段：挂载点 

- 第三字段：文件系统名称 

- 第四字段：挂载参数 

- 第五字段：指定分区是否被dump备份，0代表不备份，1 代表每天备份，2代表不定期备份 

- 第六字段：指定分区是否被fsck检测，0代表不检测，其他数字代表检测的优先级，那么当然1的优先级比2高  


2. 分区自动挂载 [root@localhost ~]# vi /etc/fstab 


…省略部分输出… 
/dev/sdb5               /disk5                  ext4    defaults        1 2  

3. /etc/fstab文件修复 [root@localhost ~]# mount -o remount,rw /


#### **9.4 分配swap分区**

1. 新建swap分区 


[root@localhost ~]# fdisk /dev/sdb  
别忘记把分区ID改为82

2. 格式化 


[root@localhost ~]# mkswap /dev/sdb1   

3. 加入swap分区 


[root@localhost ~]# swapon /dev/sdb1 
#加入swap分区 
[root@localhost ~]# swapoff /dev/sdb1 
#取消swap分区

4. swap分区开机自动挂载 


[root@localhost ~]# vi /etc/fstab 
/dev/sdb1        swap                    swap    defaults        0 0  

5. free命令 


[root@localhost ~]# free  
#查看内存与swap分区使用状况 

- cached（缓存）：是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程 

- buffer（缓冲）：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程

## 第十章 Shell 基础

### 10.1 Shell 概述

1. Shell 是什么 

- Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498938-7c35ce85-82c9-42e8-8c1a-4d60521cc3ca.png#align=left&display=inline&height=526&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=654&size=0&status=done&style=none&width=654)

- Shell 还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用 Linux 系统命令。


2. Shell 的分类 

- Bourne Shell：从1979起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为sh。 

- C Shell： C Shell主要在BSD版的 Unix 系统中使用，其语法和 C 语言相类似而得名

- Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zsh；C 家族主要包括：csh、tcsh 

- Bash： Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。


3. Linux 支持的 Shell 

- /etc/shells



### 10.2 Shell 脚本的执行方式

1. echo 输出命令 


[root@localhost ~]# echo [选项] [输出内容] 
选项：  -e： 支持反斜线控制的字符转换

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498970-654039b0-5b3f-45af-a72e-d27e45f6fc5b.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=918&size=0&status=done&style=none&width=918)

[root@localhost ~]# echo -e "ab\bc" 
#删除左侧字符  

[root@localhost ~]# echo -e "a\tb\tc\nd\te\tf" 
#制表符与换行符

[root@localhost ~]# echo -e   "\x61\t\x62\t\x63\n\x64\t\x65\t\x66" 
#按照十六进制ASCII码也同样可以输出  

[root@localhost ~]# echo -e "\e[1;31m  abcd \e[0m" 
#输出颜色
#30m=黑色，31m=红色，32m=绿色，33m=黄色 
#34m=蓝色，35m=洋红，36m=青色，37m=白色

2. 第一个脚本 


[root@localhost sh]# vi hello.sh 
#!/bin/Bash 
#The first program # Author: shenchao （E-mail: shenchao@lampbrother.net）   
echo -e "Mr. Shen Chao is the most honest man in LampBrother"

3. 脚本执行 

- 赋予执行权限，直接运行 
   - chmod 755 hello.sh 

   - ./hello.sh  

- 通过Bash调用执行脚本 
   - bash hello.sh

   - sh hello.sh


tips:[俄罗斯方块游戏代码点击下载](https://pan.baidu.com/share/init?surl=X5bg6IRSKoVC-lFuERSQOQ)
密码:du55

### 10.3 Bash 的基本功能

#### （1）历史命令与命令补全

1. 历史命令 


[root@localhost ~]# history [选项] [历史命令保存文件] 
选项：  
-c：  清空历史命令  
-w： 把缓存中的历史命令写入历史命令保存文件    
~/.bash_history 

- 历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改


历史命令的调用 

- 使用上、下箭头调用以前的历史命令 

- 使用“!n”重复执行第n条历史命令 

- 使用“!!”重复执行上一条命令 

- 使用“!字串”重复执行最后一条以该字串开头的命令  


2. 命令与文件补全 

- 在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全

#### （2） 命令别名与常用快捷键

1. 命令别名 


[root@localhost ~]# alias 别名='原命令' 
#设定命令别名  
[root@localhost ~]# alias 
#查询命令别名  

命令执行时顺序 
1 第一顺位执行用绝对路径或相对路径执行的命令。 
2 第二顺位执行别名。 
3 第三顺位执行Bash的内部命令。 
4 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。

让别名永久生效 
[root@localhost ~]# vi /root/.bashrc 

删除别名 
[root@localhost ~]# unalias 别名

2. Bash常用快捷键


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498926-e80f042e-f524-4d97-9016-08f457432230.png#align=left&display=inline&height=490&margin=%5Bobject%20Object%5D&originHeight=490&originWidth=890&size=0&status=done&style=none&width=890)
#### （3） 输入输出重定向

1. 标准输入输出


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498963-8b9d2cae-e8ad-49d5-a69e-a97eda7cf417.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&originHeight=448&originWidth=962&size=0&status=done&style=none&width=962)

2. 输出重定向


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498901-a988a0d1-f090-4595-a447-ff396f3c5763.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=932&size=0&status=done&style=none&width=932)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499061-94be62aa-95cd-47a7-b8d7-073e2f94a9f7.png#align=left&display=inline&height=554&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=950&size=0&status=done&style=none&width=950)

3. 输入重定向 


[root@localhost ~]# wc [选项] [文件名] 
选项：  
- c   统计字节数  
- w   统计单词数  
- l   统计行数  

- 命令<文件  把文件作为命令的输入 

- 命令<< 标识符    


…      
标识符   把标识符之间内容作为命令的输入
#### （4） 多命令顺序执行与管道符

1. 多命令顺序执行


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498956-d7fafb2b-25f9-406c-ac99-6840b5c9f3ec.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=906&size=0&status=done&style=none&width=906)
例子： [root@localhost ~]# ls ; date ; cd /user ; pwd

[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数  
选项：  
if=输入文件  指定源文件或源设备  
of=输出文件  指定目标文件或目标设备  
bs=字节数  指定一次输入/输出多少字节，即把这些字节看做一个数据块 
count=个数  指定输入/输出多少个数据块  
例子： 
[root@localhost ~]# date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date

[root@localhost ~]# ls anaconda-ks.cfg && echo yes  
[root@localhost ~]# ls /root/test || echo "no   
[root@localhost ~]# 命令 && echo yes || echo no

2. 管道符 


命令格式：
[root@localhost ~]# 命令1  |  命令2 
#命令1的正确输出作为命令2的操作对象 
颜色显示   

例子： 
[root@localhost ~]# ll -a /etc/  | more 
[root@localhost ~]# netstat -an | grep "ESTABLISHED"

[root@localhost ~]# grep [选项] "搜索内容" 文件名 
选项：  
-i：  忽略大小写  
-n：  输出行号  
-v：  反向查找  
--color=auto 搜索出的关键字用颜色显示

#### （5） 通配符与其他特殊符号
1、通配符
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498947-90d841d2-001f-4484-9449-4194069eeca2.png#align=left&display=inline&height=478&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=916&size=0&status=done&style=none&width=916)

```
[root@localhost ~]# cd /tmp/ 
[root@localhost tmp]# rm -rf * 
[root@localhost tmp]# touch abc 
[root@localhost tmp]# touch abcd 
[root@localhost tmp]# touch 012 
[root@localhost tmp]# touch 0abc 
[root@localhost tmp]# ls ?abc 
[root@localhost tmp]# ls [0-9]* 
[root@localhost tmp]# ls [^0-9]*
```
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499016-31ee5886-3910-4701-a9e7-1eebbf9e4fd4.png#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=502&size=0&status=done&style=none&width=502)

3. Bash中其他特殊符号 


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499003-f4a34088-064a-4b56-9e4e-31818ae28524.png#align=left&display=inline&height=496&margin=%5Bobject%20Object%5D&originHeight=496&originWidth=940&size=0&status=done&style=none&width=940)

反引号与$() 
[root@localhost ~]# echo `ls`  
[root@localhost ~]# echo $(date)  

单引号与双引号 
[root@localhost ~]# name=sc 
[root@localhost ~]# echo '$name' 
[root@localhost ~]# echo "$name" 
[root@localhost ~]# echo ‘$(date)' 
[root@localhost ~]# echo “$(date)"
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498993-c8edc91b-9110-47c0-b1a1-41931cc4db59.png#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&originHeight=316&originWidth=544&size=0&status=done&style=none&width=544)

### 10.4 Bash 的变量

#### （1） 用户自定义变量

1. 什么是变量 

- 变量是计算机内存的单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或是一个数字，就把它存放在一个变量中。每个变量有一个名字，所以很容易引用它。使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。 

2. 变量设置规则 

- 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是“2name”则是错误的。 

- 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。

- 变量用等号连接值，等号左右两侧不能有空格。 

- 变量的值如果有空格，需要使用单引号或双引号包括。 

- 在变量的值中，可以使用“\”转义符。 

- 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含。 

- 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。 

- 环境变量名建议大写，便于区分。


3. 变量分类 

- 用户自定义变量  环境变量：这种变量中主要保存的是和系统操作环境相关的数据。 

- 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 

- 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。


 4、本地变量

- 变量定义


 [root@localhost ~]# name="shen chao"

- 变量叠加


[root@localhost ~]# aa=123 
[root@localhost ~]# aa="$aa"456 
[root@localhost ~]# aa=${aa}789

- 变量调用 


[root@localhost ~]# echo $name  

- 变量查看 


[root@localhost ~]# set  
查看当前系统全部变量

- 变量删除


[root@localhost ~]# unset name

#### （2） 环境变量

1. 环境变量是什么 

- 用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效 


tips:**pstree**是以树结构显示进程(–display a tree of processes)
**提示:-bash: pstree: 未找到命令，**那么root身份执行 **yum install psmisc**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499066-66e6940c-af16-4982-856f-d813bb0d0a77.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=682&originWidth=662&size=0&status=done&style=none&width=273)

2. 设置环境变量 


export 变量名=变量值 
#申明变量  

env 
#查询变量  

unset 变量名 
#删除变量

3. 系统常见环境变量 

- PATH：系统查找命令的路径 


[root@localhost ~]# echo $PATH /usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin: /sbin:/bin:/usr/sbin:/usr/bin:/root/bin 

- PATH="$PATH":/root/sh 


#PATH变量叠加

- PS1：定义系统提示符的变量 


\d：显示日期，格式为“星期 月 日” 
\h：显示简写主机名。如默认主机名“localhost” 
\t：显示24小时制时间，格式为“HH:MM:SS” 
\T：显示12小时制时间，格式为“HH:MM:SS”
\A：显示24小时制时间，格式为“HH:MM” 
\u：显示当前用户名 
\w：显示当前所在目录的完整名称 
\W：显示当前所在目录的最后一个目录 
\#：执行的第几个命令 
\$：提示符。如果是root用户会显示提示符为“#”，如果是普通用户会显示提示符为“$”

举例： 

- [root@localhost ~]# PS1='[\u@\t \w]\$ ' 

- [root@04:50:08 /usr/local/src]#PS1='[\u@\@ \h \# \W]\$‘  

- [root@04:53 上午 localhost 31 src]#PS1='[\u@\h \W]\$ '


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634498961-b3d3b788-453c-4e1b-941a-9a6b19bffcc4.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&originHeight=90&originWidth=408&size=0&status=done&style=none&width=408)
[显示当前用户名  显示当前用户名  显示当前所在目录的最后一个目录] 提示符

#### （3） 位置参数变量

1. 位置参数变量


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499131-3f0e0712-5c85-478c-92e9-648789475c51.png#align=left&display=inline&height=484&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=912&size=0&status=done&style=none&width=912)
例子1： 
#!/bin/bash 
num1=$1 
num2=$2 
sum=$(( $num1 + $num2)) 
#变量sum的和是num1加num2 
echo $sum 
#打印变量sum的值

例子2： 
#!/bin/bash 
echo "A total of $# parameters" 
#使用$#代表所有参数的个数 
echo "The parameters is: $*" 
#使用$*代表所有的参数 
echo "The parameters is: $@" 
#使用$@也代表所有参数
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499114-bae683a9-4a5b-4c42-af00-895605312659.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&originHeight=352&originWidth=704&size=0&status=done&style=none&width=704)
例子3：$*与$@的区别 
```
#!/bin/bash 
for i in "$*" 
#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次         
do                 
echo "The parameters is: $i"         
done 
x=1 
for y in "$@" 
#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次        
do                
echo "The parameter$x is: $y"                
x=$(( $x +1 ))       
done
```

#### （4） 预定义变量

1. 预定义变量


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499070-c23e7e2a-5267-4792-9be6-276f5719eba8.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=938&size=0&status=done&style=none&width=938)
```
#/bin/bash
# Author: shenchao （E-mail: shenchao@lampbrother.net）   
echo "The current process is $$" 
#输出当前进程的PID。 
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID   
find /root -name hello.sh & 
#使用find命令在root目录下查找hello.sh文件 
#符号&的意思是把命令放入后台执行，工作管理我们在系统管理章节会详细介绍 
echo "The last one Daemon process is $!"
```

2. 接收键盘输入 


[root@localhost ~]# read [选项] [变量名] 
选项：  
-p “提示信息”：在等待read输入时，输出提示信息  
-t 秒数：  read命令会一直等待用户输入，使用此选项可以指定等待时间  
-n 字符数： read命令只接受指定的字符数，就会 执行  
-s：   隐藏输入的数据，适用于机密信息的输入  
```
#!/bin/bash 
#Author: shenchao （E-mail: shenchao@lampbrother.net） 
read -t 30 -p "Please input your name: " name 
#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中 
echo "Name is $name "  
read -s -t 30 -p "Please enter your age: " age 
#年龄是隐私，所以我们用“-s”选项隐藏输入 
echo -e "\n" 
echo "Age is $age "  
read -n 1 -t 30 -p "Please select your gender[M/F]: " gender
#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车） 
echo -e "\n" 
echo "Sex is $gender"
```
### 10.5 Bash 的运算符

#### （1） 数值运算与运算符

1. declare声明变量类型 


[root@localhost ~]# declare [+/-][选项] 变量名 
选项：  
 -：  给变量设定类型属性  
  +:  取消变量的类型属性  
 -i:  将变量声明为整数型（integer）  
-x: 将变量声明为环境变量  
-p:  显示指定变量的被声明的类型 

2. 数值运算


方法1 :
[root@localhost ~]# aa=11 
[root@localhost ~]# bb=22 #给变量aa和bb赋值
[root@localhost ~]# declare -i cc=$aa+$bb
**方法2：expr或let数值运算工具 **
[root@localhost ~]# aa=11 
[root@localhost ~]# bb=22 
#给变量aa和变量bb赋值 
[root@localhost ~]# dd=$(expr $aa + $bb) 
#dd的值是aa和bb的和。注意“+”号左右两侧必须有空格  
**方法3：“$((运算式))”或“$[运算式]”** (推荐)
[root@localhost ~]# aa=11 
[root@localhost ~]# bb=22 
[root@localhost ~]# ff=$(( $aa+$bb )) 
[root@localhost ~]# gg=$[ $aa+$bb ]

3. 运算符


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499128-28203194-7ee7-4999-80ed-ee188a07429c.png#align=left&display=inline&height=570&margin=%5Bobject%20Object%5D&originHeight=570&originWidth=992&size=0&status=done&style=none&width=992)

```
[root@localhost ~]$ aa=$(( (11+3)*3/2 ))  
#虽然乘和除的优先级高于加，但是通过小括号可以调整运算优先级
[root@localhost ~]$ bb=$(( 14%3 ))  
#14不能被3整除，余数是2  
[root@localhost ~]$ cc=$(( 1 && 0 )) 
#逻辑与运算只有想与的两边都是1，与的结果才是1，否则与的结果是0
```
#### （2） 变量测试与内容替换
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499191-3d50a332-2090-4533-82e8-f7058a6a1cce.png#align=left&display=inline&height=584&margin=%5Bobject%20Object%5D&originHeight=584&originWidth=918&size=0&status=done&style=none&width=918)
例子1：测试x = $ { y - 新值} 
```
[root@localhost ~]# unset y 
#删除变量y 
[root@localhost ~]# x=${y-new} 
#进行测试 
[root@localhost ~]# echo $x new 
#因为变量y不存在，所以x=new  
[root@localhost ~]# y="" 
#给变量y赋值为空 
[root@localhost ~]# x=${y-new} 
#进行测试 
[root@localhost ~]# echo $x
[root@localhost ~]# y=old 
#给变量y赋值 
[root@localhost ~]# x=${y-new} 
#进行测试 [root@localhost ~]# echo $x    
old  
```
### 10.6 环境变量配置文件

#### （1） 环境变量配置文件简介

1. source命令 


[root@localhost ~]# source 配置文件 
或 
[root@localhost ~]# . 配置文件  

2. 环境变量配置文件简介 

- 环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量。

- /etc/profile 

- /etc/profile.d/*.sh 

- ~/.bash_profile 

- ~/.bashrc 

- /etc/bashrc



#### （2） 环境变量配置文件作用

- /etc/profile 

- /etc/profile.d/*.sh 

- ~/.bash_profile 

- ~/.bashrc 

- /etc/bashrc


tips:/etc 目录下的对所有用户都生效
~/.bash_profile 和 ~/.bashrc -> 每个用户自己的配置文件，只对用户生效。

下图为配置文件读取顺序：
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499211-0980d778-1b61-4a6d-9b3f-f538c11ae865.png#align=left&display=inline&height=723&margin=%5Bobject%20Object%5D&originHeight=860&originWidth=1522&size=0&status=done&style=none&width=1280)
上图从左到右如果没有叠加。后面的命令会覆盖前面的命令。
/etc/profile的作用： 

- USER变量： 

- LOGNAME变量： 

- MAIL变量： 

- PATH变量： 

- HOSTNAME变量： 

- HISTSIZE变量： 

- umask： 

- 调用/etc/profile.d/*.sh文件  


~/.bash_profile的作用 

- 用了~/.bashrc文件。 

- 在PATH变量后面加入了“:$HOME/bin”这个目录



#### （3） 其他配置文件和登录信息

1. 注销时生效的环境变量配置文件 

- ~/.bash_logout  

2. 其他配置文件

- ~/bash_history

3. Shell登录信息 

- 本地终端欢迎信息： /etc/issue


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499128-b41de53d-9b47-477e-91f5-d1871bc86c68.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=942&size=0&status=done&style=none&width=942)

- 远程终端欢迎信息： /etc/issue.net 
   - 转义符在/etc/issue.net文件中不能使用 

   - 是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net”行才能显示（记得重启SSH服务）   

- 登陆后欢迎信息：/etc/motd 


不管是本地登录，还是远程登录，都可以显示此欢迎信息

## 第十一章 Shell 编程

### 11.1 基础正则表达式

1. 正则表达式与通配符 

- 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 

- 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。


2、基础正则表达式
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499148-893742b4-80f4-484c-9686-f17f13c0a5c9.png#align=left&display=inline&height=776&margin=%5Bobject%20Object%5D&originHeight=824&originWidth=1360&size=0&status=done&style=none&width=1280)
 “*”前一个字符匹配0次，或任意多次 

- grep "a*" test_rule.txt  


#匹配所有内容，包括空白行

- grep "aa*" test_rule.txt 


#匹配至少包含有一个a的行 

- grep "aaa*" test_rule.txt  


#匹配最少包含两个连续a的字符串 

- grep "aaaaa*" test_rule.txt 


#则会匹配最少包含四个个连续a的字符串

“.” 匹配除了换行符外任意一个字符 

- grep  "s..d" test_rule.txt  


#“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词 

- grep "s.*d" test_rule.txt  


#匹配在s和d字母之间有任意字符 

- grep ".*" test_rule.txt  


#匹配所有内容

“^”匹配行首，“$”匹配行尾 

- grep "^M" test_rule.txt 


#匹配以大写“M”开头的行 

- grep "n$" test_rule.txt 


#匹配以小写“n”结尾的行 

- grep -n "^$" test_rule.txt 


#会匹配空白行 

“[]” 匹配中括号中指定的任意一个字符，只匹配一个字符

- grep "s[ao]id" test_rule.txt


#匹配s和i字母中，要不是a、要不是o 

- grep "[0-9]" test_rule.txt


#匹配任意一个数字 

- grep "^[a-z]" test_rule.txt 


#匹配用小写字母开头的行

“[^]” 匹配除中括号的字符以外的任意一个字符 

- grep "^[â-z]" test_rule.txt  


#匹配不用小写字母开头的行 

- grep "^[â-zA-Z]" test_rule.txt 


#匹配不用字母开头的行 “\” 转义符 

- grep "\.$" test_rule.txt


#匹配使用“.”结尾的行

“\{n\}”表示其前面的字符恰好出现n次 

- grep "a\{3\}" test_rule.txt 


#匹配a字母连续出现三次的字符串 

- grep "[0-9]\{3\}" test_rule.txt 


#匹配包含连续的三个数字的字符串   

“\{n,\}”表示其前面的字符出现不小于n次 

- grep "^[0-9]\{3,\}[a-z]" test_rule.txt 


#匹配最少用连续三个数字开头的行

“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次 

- grep "sa\{1,3\}i" test_rule.txt 


#匹配在字母s和字母i之间有最少一个a，最多三个a

### 11.2 字符截取命令

#### （1）  cut字段提取命令
[root@localhost ~]# cut [选项] 文件名 
选项：  
-f  列号：  	   提取第几列  
-d 分隔符：  按照指定分隔符分割列

[root@localhost ~]# vi student.txt 
ID      Name    gender  Mark 
1        Liming    M         86 
2        Sc           M         90 
3        Gao        M         83  

[root@localhost ~]# cut -f 2 student.txt  
#提取第二列
[root@localhost ~]# cut -f 2,3 student.txt  
#提取第二第三列
[root@localhost ~]# cut -d ":" -f 1,3 /etc/passwd
#以：为分隔符提取第一第三列

cut命令的局限 
[root@localhost ~]# df -h | cut -d " " -f 1,3
#有空格时提取会出问题

#### （2）  printf 命令
[root@localhost ~]# printf   ’输出类型输出格式’    输出内容 
输出类型：  
%ns ：  输出字符串。n是数字指代输出几个字符  
%ni ：  输出整数。n是数字指代输出几个数字  
%m.nf ： 输出浮点数。m和n是数字，指代输出的整数   位数和小数位数。如%8.2f代表共输出8位数，   其中2位是小数，6位是整数。 

输出格式：  
\a :    输出警告声音  
\b :    输出退格键，也就是Backspace键 
\f :    清除屏幕  
\n :    换行  
\r :    回车，也就是Enter键  
\t :    水平输出退格键，也就是Tab键  
\v :    垂直输出退格键，也就是Tab键

[root@localhost ~]# printf %s 1 2 3 4 5 6  
[root@localhost ~]# printf %s %s %s 1 2 3 4 5 6  
[root@localhost ~]# printf  '%s %s %s' 1 2 3 4 5 6  
[root@localhost ~]# printf '%s %s %s\n' 1 2 3 4 5 6 
tips:printf  '%s %s %s\n' 1 2 3 4 5 6 
三个看成一个整体所以123是一个整体，456是另一个。所以在3后面换行
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499142-3c414af8-500d-4304-b588-6d210fb671f9.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=802&size=0&status=done&style=none&width=802)

[root@localhost ~]# vi student.txt  
ID      Name      PHP     Linux   MySQL   Average 
1       Liming     82         95         86            87.66 
2       Sc             74         96         87            85.66 
3       Gao           99         83         93           91.66

printf  '%s' $(cat student.txt) 
#不调整输出格式  

printf '%s\t %s\t %s\t %s\t %s\t %s\t \n' $(cat student.txt) 
#调整格式输出 

在awk命令的输出中支持print和printf命令 

- print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命

- printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符


#### （3）awk 命令
[root@localhost ~]# awk ‘条件1{动作1} 条件2{动作2}…’ 文件名 
条件（Pattern）：  
一般使用关系表达式作为条件  
x > 10 判断变量 x是否大于10  
x>=10 大于等于 
x<=10 小于等于 
动作（Action）：  
格式化输出  
流程控制语句   

[root@localhost ~]# vi student.txt  
ID      Name      PHP     Linux   MySQL   Average 
1        Liming    82        95         86             87.66 
2        Sc            74        96         87             85.66 
3        Gao          99        83        93              91.66

[root@localhost ~]#awk '{printf $2 "\t" $6 "\n"}' student.txt   
[root@localhost ~]# df -h | awk '{print $1 "\t" $3}'    
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499236-2e47dd5f-7067-41da-ae5f-4c4c54234c66.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&originHeight=768&originWidth=870&size=0&status=done&style=none&width=397)
提取已用百分比
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499251-8bef01e4-e7f3-4d6e-ade0-be40caeabd5a.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=988&size=0&status=done&style=none&width=988)

**BEGIN** 
#awk 'BEGIN{printf "This is a transcript \n" }  {printf $2 "\t" $6 "\n"}' student.txt

**END** 
# awk 'END{printf "The End \n" }                             
{printf $2 "\t" $6 "\n"}' student.txt  

**FS内置变量 **
#cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}'

**关系运算符 **
#cat student.txt | grep -v Name |  awk '$6 >= 87 {printf $2 "\n" }'

#### （4）sed 命令

**sed命令 **

- sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。


 
[root@localhost ~]# sed [选项] ‘[动作]’ 文件名 
选项：  
-n：  一般sed命令会把所有数据都输出到屏幕 ，  如果加入此选择，则只会把经过           		sed命令处  理的行输出到屏幕。 
 -e： 允许对输入数据应用多条sed命令编辑 
 -i：  用sed的修改结果直接修改读取数据的文件，  而不是由屏幕输出

动作：  
a \：  追加，在当前行后添加一行或多行。添加多行时，除最后 一行  外，每行末尾需要用“\”代	     		表数据未完结。 
c \：  行替换，用c后面的字符串替换原数据行，替换多行时，除最  后一行外，每行末尾需“\”代   		表数据未完结。
      i \：  插入，在当期行前插入一行或多行。插入多行时，除最后 一行  外，每行末尾需要“\”代
表数据未完结。 
d：  删除，删除指定的行。 
      p：  打印，输出指定的行。 
      s：  字串替换，用一个字符串替换另外一个字符串。格式为“行范  围s/旧字串/新字串/g”（和vim
中的替换格式类似）。 

学生成绩表 
[root@localhost ~]# vi student.txt  
ID      Name      PHP     Linux   MySQL   Average 
1        Liming    82        95         86             87.66 
2        Sc            74        96         87             85.66 
3        Gao         99        83         93             91.66

**行数据操作 **
[root@localhost ~]# sed '2p' student.txt  
#查看文件的第二行  
[root@localhost ~]# sed -n '2p' student.txt    
[root@localhost ~]# sed '2,4d' student.txt  
#删除第二行到第四行的数据，但不修改文件本身
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499149-9661cc7e-2382-44b5-9f34-ab8178a76940.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=574&size=0&status=done&style=none&width=463)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499239-4f7bde42-516c-4219-aa95-693aae2a7e1c.png#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=632&size=0&status=done&style=none&width=458)

[root@localhost ~]# sed '2a hello' student.txt   
#在第二行后追加hello  
[root@localhost ~]# sed '2i hello \ world' student.txt 
#在第二行前插入两行数据  
# sed '2c No such person‘ student.txt 
#数据替换

**字符串替换** 
# sed ‘s/旧字串/新字串/g’ 文件名  

# sed '3s/74/99/g' student.txt  
#在第三行中，把74换成99 
#sed -i '3s/74/99/g' student.txt  
#sed操作的数据直接写入文件  

# sed -e 's/Liming//g ; s/Gao//g' student.txt  
#同时把“Liming”和“Gao”替换为空

### 11.3 字符处理命令

1. 排序命令sort  


[root@localhost ~]# sort [选项] 文件名 
选项： 
-f：  忽略大小写  
-n：  以数值型进行排序，默认使用字符串型排序  
-r：  反向排序  
-t：  指定分隔符，默认是分隔符是制表符  
-k n[,m]： 按照指定的字段范围排序。从第n字段开始，  m字段结束（默认到行尾）  

[root@localhost ~]# sort /etc/passwd 
#排序用户信息文件  

[root@localhost ~]# sort -r /etc/passwd 
#反向排序

[root@localhost ~]# sort -t ":" -k 3,3 /etc/passwd 
#指定分隔符是“：”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序  

[root@localhost ~]# sort -n -t ":" -k 3,3 /etc/passwd  

2. 统计命令wc 


[root@localhost ~]# wc [选项] 文件名 
选项：  
-l： 只统计行数  
-w： 只统计单词数  
-m： 只统计字符数

### 11.4 条件判断
**

1. **按照文件类型进行判断**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499243-deecfe26-3018-4057-afb7-a3749852ee10.png#align=left&display=inline&height=747&margin=%5Bobject%20Object%5D&originHeight=824&originWidth=1412&size=0&status=done&style=none&width=1280)
两种判断格式 
[root@localhost ~]# test -e /root/install.log   
[root@localhost ~]# [ -e /root/install.log ] 
[ -d /root ] && echo "yes" || echo "no"  
#第一个判断命令如果正确执行，则打印“yes”，否则打印“no”
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499268-941b1b02-e3ab-48e0-bbea-ba1005f1c643.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&originHeight=726&originWidth=888&size=0&status=done&style=none&width=433)

2. **按照文件权限进行判断**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499241-bb232a5c-4cca-4e61-849e-45194585defe.png#align=left&display=inline&height=644&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1240&size=0&status=done&style=none&width=1240)

[ -w student.txt ] && echo "yes" || echo "no"                   
#判断文件是拥有写权限的

3. **两个文件之间进行比较**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499361-d0d69540-6f22-4e3e-9a1b-dc6ff0336afc.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&originHeight=586&originWidth=1226&size=0&status=done&style=none&width=1226)
ln /root/student.txt /tmp/stu.txt 
#创建个硬链接吧 
[ /root/student.txt -ef /tmp/stu.txt ] && echo "yes" || echo "no" yes 
#用test测试下，果然很有用

4. **两个整数之间比较**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499271-11459d80-a143-4804-acc9-350fec7a25e6.png#align=left&display=inline&height=598&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=1208&size=0&status=done&style=none&width=1208)
[ 23 -ge 22 ] && echo "yes" || echo "no"                                   yes 
#判断23是否大于等于22，当然是了  
[ 23 -le 22 ] && echo "yes" || echo "no"  no 
#判断23是否小于等于22，当然不是了

**5、字符串的判断**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499369-297c4aa3-ecc2-4659-86b9-8306e0647c6c.png#align=left&display=inline&height=618&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1210&size=0&status=done&style=none&width=1210)
name=sc 
#给name变量赋值 
[ -z "$name" ] && echo "yes" || echo "no"  
no 
#判断name变量是否为空，因为不为空，所以返回no  

aa=11 
bb=22 
#给变量aa和变量bb赋值 
[ "$aa" == "bb" ] && echo "yes" || echo "no"            
no 
#判断两个变量的值是否相等，明显不相等，所以返回no

6、**多重条件判断**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499384-65b7e020-58a8-471a-8f33-da2e1837e7a6.png#align=left&display=inline&height=556&margin=%5Bobject%20Object%5D&originHeight=556&originWidth=1164&size=0&status=done&style=none&width=1164)
aa=11 
[ -n "$aa"  -a "$aa" -gt 23 ] && echo "yes" || echo "no" 
no 
#判断变量aa是否有值，同时判断变量aa的是否大于23 
#因为变量aa的值不大于23，所以虽然第一个判断值为真，返回的结果也是假  

aa=24 
[ -n "$aa"  -a "$aa" -gt 23 ] && echo "yes" || echo "no" yes

### 11.5 流程控制

##### **（1）if 语句**
**

1. 单分支if条件语句 

```
if  [ 条件判断式 ] ; then
程序 
fi  
#或者
if  [ 条件判断式 ]  
    then
        	程序 
fi 
```


单分支条件语句需要注意几个点

- if语句使用fi结尾，和一般语言使用大括号结尾不同 

- [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格

- then后面跟符合条件之后执行的程序，可以放在[]之后，用“；”分割。也可以换行写入，就不需要“；”了


例子：判断分区使用率 
```
#!/bin/basn
# 统计根分区使用率 
# Author: shenchao （E-mail: shenchao@qq.com）  
 rate=$(df -h | grep "/dev/sda3" | awk '{print $5}' | cut -d "%" -f 1)  
 # 把根分区使用率作为变量值赋予变量rate  
 if [ $rate -ge 80]
    then
        echo "Warning! /dev/sda3 is full!"
 fi
```

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1613634499431-2b2d20a9-7f3e-4c4d-a955-224ba28a6026.png#align=left&display=inline&height=662&margin=%5Bobject%20Object%5D&originHeight=662&originWidth=1020&size=0&status=done&style=none&width=1020)


2. 双分支if条件语句 

```
if [ 条件判断式 ] 
    then   
        条件成立时，执行的程序  
    else 
        条件不成立时，执行的另一个程序 
fi

```

例子1：备份mysql数据库 
```
#!/bin/bash
#备份mysql数据库。
# Author:shenchao（E-mail:shenchao@lampbrother.net）
ntpdateasia.pool.ntp.org&>/dev/null
#同步系统时间
date=$(date+%y%m%d)
#把当前系统时间按照“年月日”格式赋予变量
datesize=$(du-sh/var/lib/mysql)
#统计mysql数据库的大小，并把大小赋予size变量
if [ -d/tmp/dbbak ]
    then
        echo"Date:$date!" > /tmp/dbbak/dbinfo.txt
        echo"Datasize$size">>/tmp/dbbak/dbinfo.txt
        cd/tmp/dbbak
        tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &>/dev/null
        rm -rf /tmp/dbbak/dbinfo.txt
    else
        mkdir /tmp/dbbak
        echo"Date:date!">/tmp/dbbak/dbinfo.txt
        echo"Datasize:size">>/tmp/dbbak/dbinfo.txt
        cd/tmp/dbbak
        tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql  
         dbinfo.txt &> /dev/null
         rm -rf /tmp/dbbak/dbinfo.txt
 fi
```

例子2：判断apache是否启动
```
#!/bin/bash
#Author:shenchao（E-mail:shenchao@lampbrother.net）
port=$(nmap -sT 192.168.1.156 | grep tcp | grep http |awk'{print$2}')
#使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port
if [ "$port"=="open" ]
    then
        echo“$(date)httpdisok!” >> /tmp/autostart-acc.log
    else
        /etc/rc.d/init.d/httpdstart &> /dev/null
        echo"$(date)restarthttpd!!" >> /tmp/autostart-err.log
fi

```

3. 多分支if条件语句

```
if [ 条件判断式1 ]
    then
        当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
    then
        当条件判断式2成立时，执行程序2
„省略更多条件…
else
    当所有条件都不成立时，最后执行此程序
fi

```

例子
```
#!/bin/bash
#判断用户输入的是什么文件
#Author:shenchao（E-mail:shenchao@lampbrother.net）
read-p"Pleaseinputafilename:"file
#接收键盘的输入，并赋予变量file
if [ -z "$file" ]
#判断file变量是否为空       
    then
        echo "Error,pleaseinputafilename"
        exit 1
elif [ ! -e "$file" ]
#判断file的值是否存在
    then
        echo "Yourinputisnotafile!"
        exit 2
elif [ -f "$file" ]
#判断file的值是否为普通文件
    then 
    echo "$fileisaregularefile!"
elif [ -d "$file" ]
#判断file的值是否为目录文件  
    then
        echo "$fileisadirectory!"
else
    echo"$fileisanotherfile!"
fi
```

##### **（2）case 语句 **
**
**多分支case条件语句 **

- case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。

```
case $ 变量名 in  
    " 值1"）   
         如果变量的值等于值1，则执行程序1   
        ; ;
     " 值2"）   
         如果变量的值等于值2，则执行程序2  
          ; ;  
      …省略其他分支…  
      * ）   
      如果变量的值都不是以上的值，则执行此程序 
      ; ;
esac 

```
```
#!/bin/bash
#判断用户输入
#Author:shenchao（E-mail:shenchao@lampbrother.net）
read -p"Pleasechooseyes/no:" -t 30 cho
case $cho in
    "yes")
        echo"Yourchooseisyes!"
        ;;       
    "no")
        echo"Yourchooseisno!"
        ;;
    *)
    echo"Yourchooseiserror!"
    ;;
esac

```

##### **（3）for 循环 **
语法一
```
for 变量 in 值1 值2 值3
    do 
        程序
    done

```
```
#!/bin/bash
for city in beijing nanjing shanghai 
    do
        echo "this city is $city "
    done 

```

输出：
this city is beijing 
this city is nanjing 
this city is shanghai 
```
#!/bin/bash
#批量解压缩脚本
cd /sh
ls *.tar.gz -> ls.log
for i in $(cat ls.log)
    do
       tar -zxf $i &> /dev/null
    done 
rm -rf /sh/ls.log

```

语法二
```
for((初始值;循环控制条件;变量变化))
    do
        程序
    done

```
```
#!/bin/bash
#从1加到100
#Author
num=0
for((i=1;i<=100;i++))
    do
        num=$(($num+$i))
    done
echo "this sum of 1+2+...+100 is: $num"

```

##### **（4）while 循环与 until 循环**
**

1. **while循环 **

- while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样了。


```
while [ 条件判断式 ]
    do
        程序
    done

```
```
#!/bin/bash
#从1加到100
#Author:shenchao（E-mail:shenchao@lampbrother.net）
i=1
s=0
while [ $i -le 100 ] 
#如果变量i的值小于等于100，则执行循环
    do
        s=$(($s+$i))
        i=$(($i+1))
    done
echo"Thesumis:$s"

```


2. until循环 

- until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。

```
until [ 条件判断式 ]
    do
        程序
    done

```
```
#!/bin/bash
#从1加到100
#Author:shenchao（E-mail:shenchao@lampbrother.net）
i=1
s=0
until [ $i -gt 100 ]
#循环直到变量i的值大于100，就停止循环
    do
        s=$(($s+$i))i=$(($i+1))
    done
echo"Thesumis:$s"

```

### 11.6 函数

语法：
```
[ function ] funname [()]{
    action;
    [return int;]
}
```

[] -> 表示可以省略
**tips:在以上的函数语法中，前面的funcation 表示声明一个函数！！！ 可以不写 return -n 是指退出函数**
**参考：**[https://www.cnblogs.com/YankaiJY/p/8832436.html](https://www.cnblogs.com/YankaiJY/p/8832436.html)

```
#!/bin/bash
funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"return $(($aNum+$anotherNum))}
funWithReturn
echo "输入的两个数字之和为 $? !"
```

输出：
```
[timo@local1 sh]$ sh function.sh 
这个函数会对输入的两个数字进行相加运算...
输入第一个数字: 
12
输入第二个数字: 
22
两个数字分别为 12 和 22 !
输入的两个数字之和为 34 !
```
## 
## 第十二讲 Linux 服务管理

### 12.1  服务简介与分类

1. 服务的分类


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593061159-8399e379-3557-4c8d-92e7-82874431d96b.png#align=left&display=inline&height=606&margin=%5Bobject%20Object%5D&originHeight=606&originWidth=1100&size=0&status=done&style=none&width=1100)
启动与自启动 

- 服务启动：就是在当前系统中让服务运行，并提供功能。 

- 服务自启动：自启动是指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。


查询已安装的服务

- RPM包安装的服务 
   - chkconfig  --list 


#查看服务自启动状态，可以看到所有RPM包安装的服务  

- 源码包安装的服务 
   - 查看服务安装位置，一般是/usr/local/下


RPM安装服务和源码包安装服务的区别

- RPM安装服务和源码包安装服务的区别就是安装位置的不同
   - 源码包安装在指定位置，一般是/usr/local/ 

   - RPM包安装在默认位置中

### 12.2 RPM 包安装服务的管理
#### 
#### (1)  独立服务的管理
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593061160-457ef9b1-6a30-47c5-9b25-baaf8f097982.png#align=left&display=inline&height=606&margin=%5Bobject%20Object%5D&originHeight=606&originWidth=1100&size=0&status=done&style=none&width=1100)

1. RPM包安装服务的位置 

- RPM安装服务和源码包安装服务的区别就是安装位置的不同
   - 源码包安装在指定位置，一般是/usr/local/ 

   - RPM包安装在默认位置中 /etc/init.d/：启动脚本位置

- /etc/sysconfig/：初始化环境配置文件位置 

- /etc/：配置文件位置 

- /etc/xinetd.conf：xinetd配置文件 

- /etc/xinetd.d/：基于xinetd服务的启动脚本

- /var/lib/：服务产生的数据放在这里 

- /var/log/：日志


2. 独立服务的启动 

- /etc/init.d/独立服务名  start|stop|status|restart|    

- service  独立服务名  start|stop|restart||status 


3. 独立服务的自启动 

- chkconfig [--level 运行级别] [独立服务名] [on|off]   

- 修改/etc/rc.d/rc.local文件   

- 使用ntsysv命令管理自启动


**tips: **service和chkconfig命令的功能在Centos7中好像都被阉割了。被**systemctl**取代。
参考博文：[Centos7下的systemctl命令与service和chkconfig](https://blog.csdn.net/cds86333774/article/details/51165361)

#### (2) 基于xinetd服务的管理
**Xinetd：**即extended internet daemon，是新一代的网络守护进程服务程序，又叫超级Internet服务器，常用来管理多种轻量级Internet服务。Xinetd提供类似于inetd+tcp_wrapper的功能，但是更加强大和安全。
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593061169-c076f6da-04cd-4e09-b0c0-eb270bd2e2a6.png#align=left&display=inline&height=606&margin=%5Bobject%20Object%5D&originHeight=606&originWidth=1100&size=0&status=done&style=none&width=1100)

1. 安装xinetd与telnet 


[root@localhost ~]# yum -y install xinetd  

[root@localhost ~]# yum -y install telnet-server 

2. xinetd服务的启动


[root@localhost ~]# vi /etc/xinetd.d/telnet 
service telnet  <- 服务的名称为telnet
 {         
flags           = REUSE  <- 标志为REUSE，设定TCP/IP socket可重用
socket_type     = stream  <-使用TCP协议数据包         
wait            = no  <-允许多个连接同时连接         
user            = root  <- 启动服务的用户为root         
server          = /usr/sbin/in.telnetd  <- 服务的启动程序         
log_on_failure  += USERID  <- 登陆失败后，记录用户的ID         
disable         = no   <- 服务不启动
}

重启xinetd服务 [root@localhost ~]# service xinetd restart

3. xinetd服务的自启动 

- [root@localhost ~]# chkconfig telnet on   

- ntsysv

### 12.3 源码包安装服务的管理

1. 源码包安装服务的启动 

- 使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。 


 /usr/local/apache2/bin/apachectl  start|stop 

2. 源码包服务的自启动 


[root@localhost ~]# vi /etc/rc.d/rc.local 
加入 
/usr/local/apache2/bin/apachectl  start

3. 让源码包服务被服务管理命令识别 

- 让源码包的apache服务能被service命令管理启动 


ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache   

- 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动  


vi /etc/init.d/apache 
# chkconfig: 35 86 76 
#指定httpd脚本可以被chkconfig命令管理。格式是：  
chkconfig： 运行级别 启动顺序 关闭顺序 
# description: source package apache 
#说明，内容随意

[root@localhost ~]# chkconfig --add apache 
#把源码包apache加入chkconfig命令

### 12.4 服务管理总结
脑图地址

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593061129-50c9e418-93d7-41e8-bf8c-70f59c5424e4.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&originHeight=1052&originWidth=1768&size=0&status=done&style=none&width=630)
## 
## 第十三章 Linux 系统管理

### 13.1 进程管理

#### (1)  进程查看

1. 进程简介 

- 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 

2. 进程管理的作用

- 判断服务器健康状态 

- 查看系统中所有进程 

- 杀死进程


3. 查看系统中所有进程


[root@localhost ~]# ps aux 
#查看系统中所有进程，使用BSD操作系统格式 
[root@localhost ~]# ps -le 
#查看系统中所有进程，使用Linux标准命令格式。 

- USER：该进程是由哪个用户产生的； 

- PID：进程的ID号； 

- %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；

- %MEN：该进程占用物理内存的百分比，占用越高，进程越耗费资源； 

- VSZ: 该进程占用虚拟内存的大小，单位KB；

- RSS：该进程占用实际物理内存的大小，单位KB； 

- TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7 是图形终端。pts/0-255代表虚拟终端。

- STAT：进程状态。常见的状态有：
   - R：运行

   - S：睡眠

   - T：停止状态

   - s：包含子进程

   - +：位于后台 

- START：该进程的启动时间 

- TIME：该进程占用CPU的运算时间，注意不是系统时间 

- COMMAND：产生此进程的命令名


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104321-d5ac448a-c6be-4f83-b88a-8b1776e3d53a.png#align=left&display=inline&height=293&margin=%5Bobject%20Object%5D&originHeight=360&originWidth=1572&size=0&status=done&style=none&width=1280)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104304-8405e79f-bcb2-4865-a087-660fa18599cb.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=336&originWidth=1394&size=0&status=done&style=none&width=1280)
**tips: ps aux 和 ps -ef 区别**
两者没太大差别，讨论这个问题，要追溯到Unix系统中的两种风格，System Ｖ风格和BSD 风格，ps aux最初用到Unix Style中，而ps -ef被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。
其中各列的内容意思如下
UID    //用户ID、但输出的是用户名 
PID    //进程的ID 
PPID    //父进程ID 
C      //进程占用CPU的百分比 
STIME  //进程启动到现在的时间 
TTY    //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。 
CMD    //命令的名称和参数

4. 查看系统健康状态 


[root@localhost]#  top [ 选项] 
选项： 
- d  秒数： 指定top命令每隔几秒更新。默认是3秒 在top命令的交互模式当中可以执行的命令：  
？或h：  显示交互模式的帮助  
P：   以CPU使用率排序，默认就是此项  
M：   以内存的使用率排序  
N：   以PID排序  
q：   退出top

**第一行信息为任务队列信息 [重点关注load average]**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104381-63177dcc-e453-405f-a164-3c9ad317ad50.png#align=left&display=inline&height=462&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=864&size=0&status=done&style=none&width=864)

**第二行为进程信息**![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104399-ff55c673-46e1-4e3f-98cf-ee2cd5889dc4.png#align=left&display=inline&height=484&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=912&size=0&status=done&style=none&width=912)
**第三行为CPU信息 [重点关注 id(空闲cpu百分比)]**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104357-763e3c88-4a21-486d-984c-32b46e2a9736.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&originHeight=532&originWidth=942&size=0&status=done&style=none&width=942)
**第四行为物理内存信息 [重点关注free]**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104431-13c775b0-da92-45b8-8940-c8bf2c430dc3.png#align=left&display=inline&height=504&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=944&size=0&status=done&style=none&width=944)
**第五行为交换分区（swap）信息**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104458-01b64c0f-9e78-4a7e-82a7-9b91bc0e1a8d.png#align=left&display=inline&height=488&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=946&size=0&status=done&style=none&width=946)

5. 查看进程树 


[root@localhost]# pstree  [选项]
选项：  
- p ： 显示进程的PID  
- u ： 显示进程的所属用户
#### (2)  终止进程

1. kill命令 


[root@localhost ~]# kill –l 
#查看可用的进程信号
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104455-154dfce4-768e-4a72-808b-734916324589.png#align=left&display=inline&height=778&margin=%5Bobject%20Object%5D&originHeight=950&originWidth=1562&size=0&status=done&style=none&width=1280)

[root@localhost ~]# kill -1 22354 
#重启进程  

[root@localhost ~]# kill -9 22368 
#强制杀死进程

2. killall命令 


[root@localhost]# killall [ 选项][信号] 进程名 
#按照进程名杀死进程 
选项：  
- i ： 交互式，询问是否要杀死某个进程  
- I ： 忽略进程名的大小写  

3. pkill命令


[root@localhost]# pkill  [ 选项] [信号] 进程名 
#按照进程名终止进程 选项：  
- t  终端号： 按照终端号踢出用户

**按照终端号踢出用户 **
[root@localhost ~]# w 
#使用w命令查询本机已经登录的用户  

[root@localhost ~]# pkill -t -9 pts/1 
#强制杀死从pts/1虚拟终端登录的进程

### 13.2 工作管理

1. 把程序放入后台

- tar -zcf etc.tar.gz /etc &  [程序还在运行]

- [root@localhost ~]# top 


#在top命令执行的过程中，按下ctrl+z快捷键  [程序暂停，除非恢复]

2. 查看后台的工作


[root@localhost]# jobs [-l]
选项：
-l: 显示工作的PID
注："+"号表示最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。
"-"号代表倒数第二个放入后台的工作

3. 将后台暂停的工作恢复到前台执行


[root@localhost]# fg %工作号
参数：
%工作号：%号可以省略，但是注意工作号和PID的区别

4. 把后台暂停的工作恢复到后台执行


[root@localhost]# bg %工作号
注：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。
即：命令和前台有交互是不能恢复到后台运行。例如：top

### 13.3 系统资源查看

1. vmstat命令监控系统资源


[root@localhost ~]# vmstat [刷新延时 刷新次数]  

例如： 
[root@localhost proc]# vmstat 1 3  

2. dmesg开机时内核检测信息 


[root@localhost ~]# dmesg 
[root@localhost ~]# dmesg | grep CPU

3. free命令查看内存使用状态 


[root@localhost ~]# free [-b|-k|-m|-g] 
选项：  
-b： 以字节为单位显示  
-k： 以KB为单位显示，默认就是以   KB为单位显示  
-m： 以MB为单位显示  
-g： 以GB为单位显示  

**缓存和缓冲的区别**

- 简单来说缓存（cache）是用来加速数据从硬盘中“读取”的，而缓冲（buffer）是用来加速数据“写入”硬盘的。


tips:向硬盘写入数据的时候,现存在缓冲中,达到一定规模,写入到硬盘。减少写入写出操作。

4. 查看CPU信息


[root@localhost ~]# cat /proc/cpuinfo  

5. uptime命令 


[root@localhost ~]# uptime  
#显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据。

6. 查看系统与内核相关信息


[root@localhost ~]# uname [选项] 
选项： 
-a： 查看系统所有相关信息；  
-r： 查看内核版本；  
-s： 查看内核名称。 

** 判断当前系统的位数**
[root@localhost ~]# file /bin/ls

**查询当前Linux系统的发行版本 **
[root@localhost ~]# lsb_release -a  

7. 列出进程打开或使用的文件信息 


[root@localhost ~ ] #  lsof [ 选项] 
# 列出进程调用或打开的文件的信息 
选项： 
- c  字符串： 只列出以字符串开头的进程打开的文件  
- u  用户名： 只列出某个用户的进程打开的文   件  
- p  pid ：  列出某个PID进程打开的文件

### 13.4 系统定时任务

1. **crond服务管理与访问控制 **


[root@localhost ~]# service crond restart   

[root@localhost ~]# chkconfig crond on

2. 用户的crontab设置 


[root@localhost ~]# crontab [选项] 
选项：  
-e：  编辑crontab定时任务  
-l：  查询crontab任务  
-r：  删除当前用户所有的crontab任务

[root@localhost ~]# crontab -e 
#进入crontab编辑界面。会打开vim编辑你的工作。 
* * * * * 执行的任务
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104511-89222a9b-15cf-4c64-bb5c-02cd522766ac.png#align=left&display=inline&height=536&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=890&size=0&status=done&style=none&width=890)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104789-b993025d-11a1-44da-b62e-348f87583f4d.png#align=left&display=inline&height=552&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=900&size=0&status=done&style=none&width=900)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593104608-2dfa09b3-1cb8-4f89-857e-16c1f5d7ce30.png#align=left&display=inline&height=574&margin=%5Bobject%20Object%5D&originHeight=574&originWidth=956&size=0&status=done&style=none&width=956)
举例 
*/5 * * * * /bin/echo ”11” >> /tmp/test 
5 5 * * 2 /sbin/shutdown -r now  
0 5 1,10,15 * * /root/sh/autobak.sh
```
[yasuo@local1 tmp]$ crontab -l
*/1 * * * * echo "你好，明天$(date)" >> /tmp/test
[yasuo@local1 tmp]$ cat test  
你好，明天2020年 04月 14日 星期二 00:24:01 CST
你好，明天2020年 04月 14日 星期二 00:25:01 CST
```
### **
## 第十四讲 日志管理

### 14.1 日志管理简介
**

1. 日志服务

- 在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本和syslogd服务一致。 

- rsyslogd的新特点： 
   - 基于TCP网络协议传输日志信息； 

   - 更安全的网络传输方式；

   - 有日志消息的及时分析框架； 

   - 后台数据库； 

   - 配置文件中可以写简单的逻辑判断； 

   - 与syslog配置文件相兼容。


**确定服务启动**
[root@localhost ~]# ps aux | grep rsyslogd
#查看服务是否启动  

chkconfig --list | grep rsyslog 
systemctl list-unit-files | grep rsyslog ** [Centos7]**
#查看服务是否自启动

2. 常见日志的作用


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348278-9d0fcf0e-30f9-4b96-bf79-292207228d60.png#align=left&display=inline&height=498&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=924&size=0&status=done&style=none&width=924)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348226-fbe5734b-91c2-469a-8a30-b15fc9ce2c84.png#align=left&display=inline&height=548&margin=%5Bobject%20Object%5D&originHeight=548&originWidth=908&size=0&status=done&style=none&width=908)

- 除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在/var/log/目录中（源码包安装的服务日志是在源码包指定目录中）。不过这些日志不是由rsyslogd服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身日志。


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348286-11ea170d-b74c-4fcc-ae06-8d5d785a5193.png#align=left&display=inline&height=530&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=938&size=0&status=done&style=none&width=938)

#### **14.2 rsyslogd日志服务**

1. 日志文件格式 

- 基本日志格式包含以下四列： 
   - 事件产生的时间； 

   - 发生事件的服务器的主机名；

   - 产生事件的服务名或程序名；

   - 事件的具体信息。 

   - 


 2、/etc/rsyslog.conf配置文件 
authpriv.*                          /var/log/secure 
#服务名称[连接符号]日志等级  日志记录位置 
#认证相关服务.所有日志等级  记录在/var/log/secure日志中

**服务名称**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348285-25845918-3297-4cc5-9a98-de39a6e6b096.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=898&size=0&status=done&style=none&width=898)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348350-f3dd9435-687b-44f2-9f4d-7c3518849521.png#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=896&size=0&status=done&style=none&width=896)
**连接符号** 

- 连接符号可以识别为：
   - “*”代表所有日志等级，比如：“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录 

   - “.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如：“cron.info”代表cron服务产生的日志，只要日志等级大于等于info级别，就记录 

   - “.=”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.=emerg”代表人和日志服务产生的日志，只要等级是emerg等级就记录。这种用法及少见，了解就好 

   - “.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。


**日志等级**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348393-d3bfa910-07e8-4b45-b52d-a91a308eb1f1.png#align=left&display=inline&height=482&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=902&size=0&status=done&style=none&width=902)
**日志记录位置** 

- 日志文件的绝对路径，如“/var/log/secure”

- 系统设备文件，如“/dev/lp0” 

- 转发给远程主机，如“@192.168.0.210:514” 

- 用户名，如“root” 

- 忽略或丢弃日志，如“~”


### 14.3 日志轮替

1. **日志文件的命名规则**

- 如果配置文件中拥有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20130605”。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。 

- 如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。


2. **logrotate配置文件**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348437-414a6e92-16a8-464d-b464-ec48070a2595.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=864&size=0&status=done&style=none&width=864)
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593348476-5bdc769a-0f4c-48a0-8521-9a15ce1afc71.png#align=left&display=inline&height=536&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=878&size=0&status=done&style=none&width=878)

3. **把apache日志加入轮替 **


[root@localhost ~]# vi /etc/logrotate.conf  
/usr/local/apache2/logs/access_log {
       daily    
create     
rotate 30 
} 

4. **logrotate命令**


[root@localhost ~]# logrotate [选项] 配置文件名 
选项：  
如果此命令没有选项，则会按照配置文件中的条件进行日志轮替  
-v： 显示日志轮替过程。加了-v选项，会显示日志的轮 替的过程  
-f： 强制进行日志轮替。不管日志轮替的条件是否已经 符合，强制配置文件中所有的日志进行轮替

## 第十五章 启动管理

### 15.1 CentOS 6.x启动管理

#### (1) 系统运行级别

1. **运行级别**


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593386532-372897a6-e32d-45bb-a101-7bf4c14ec730.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=882&size=0&status=done&style=none&width=882)

2. **运行级别命令**


[root@localhost ~]# runlevel  
#查看运行级别命令  

[root@localhost ~]# init 运行级别 
#改变运行级别命令  

3. **系统默认运行级别**


[root@localhost ~]# vim /etc/inittab id:3:initdefault: #系统开机后直接进入哪个运行级别

#### (2) 系统启动过程
启动流程图

initramfs内存文件系统 

- CentOS 6.x中使用initramfs内存文件系统取代了CentOS 5.x中的initrd RAM Disk。


他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的内核模块，比如USB、SATA、SCSI 硬盘的驱动和LVM、RAID文件系统的驱动 
mkdir /tmp/initramfs 
#建立测试目录 
cp /boot/initramfs-2.6.32-279.el6.i686.img /tmp/initramfs/ 
#复制initramfs文件 
cd /tmp/initramfs/ 
file initramfs-2.6.32-279.el6.i686.img  
mv initramfs-2.6.32-279.el6.i686.img initramfs-2.6.32-279.el6.i686.img.gz 
#修改文件的后缀名为.gz 
gunzip initramfs-2.6.32-279.el6.i686.img.gz 
#解压缩  
file initramfs-2.6.32-279.el6.i686.img  
cpio -ivcdu < initramfs-2.6.32-279.el6.i686.img 
#解压缩

调用/etc/init/rcS.conf配置文件 

- 主要功能是两个： 
   - 先调用/etc/rc.d/rc.sysinit，然后由/etc/rc.d/rc.sysinit配置文件进行Linux系统初始化。 

   - 然后再调用/etc/inittab，然后由/etc/inittab配置文件确定系统的默认运行级别。 


**由/etc/rc.d/rc.sysinit初始化**

1. 获得网络环境 

1. 挂载设备 

1. 开机启动画面Plymouth（取替了过往的 RHGB）

1. 判断是否启用SELinux 

1. 显示于开机过程中的欢迎画面 

1. 初始化硬件 

1. 用户自定义模块的加载 

1. 配置内核的参数 

1. 设置主机名

1. 同步存储器 

1. 设备映射器及相关的初始化 

1. 初始化软件磁盘阵列（RAID） 

1. 初始化 LVM 的文件系统功能 

1. 检验磁盘文件系统（fsck）

1. 设置磁盘配额(quota) 

1. 重新以可读写模式挂载系统磁盘 

1. 更新quota（非必要） 

1. 启动系统虚拟随机数生成器 

1. 配置机器（非必要）

1. 清除开机过程当中的临时文件

1. 创建ICE目录 

1. 启动交换分区（swap） 

1. 将开机信息写入/var/log/dmesg文件中


调用/etc/rc.d/rc文件 

- 运行级别参数传入/etc/rc.d/rc这个脚本之后，由这个脚本文件按照不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序 
   - /etc/rc3.d/k??开头的文件（??是数字），会按照数字顺序依次关闭 

   - /etc/rc3.d/S??开头的文件（??是数字），会按照数字顺序依次启动


### 15.2 启动引导程序grub

#### (1) Grub配置文件

1. grub中分区表示


![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593386672-e1af4c63-3af7-4435-9613-c0b76ddf85c0.png#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=920&size=0&status=done&style=none&width=920)

2. grub配置文件 


vi /boot/grub/grub.conf 

- default=0  默认启动第一个系统 

- timeout=5  等待时间，默认是5秒 

- splashimage=(hd0,0)/grub/splash.xpm.gz  这里是指定grub启动时的背景图像文件的保存位置的 

- hiddenmenu 隐藏菜单

- title CentOS (2.6.32-279.el6.i686)  title就是标题的意思

- root (hd0,0)  是指启动程序的保存分区 

- kernel /vmlinuz-2.6.32-279.el6.i686 ro root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 


rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us 
rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 
rd_NO_LVM rd_NO_DM rhgb quiet  
定义内核加载时的选项

- initrd /initramfs-2.6.32-279.el6.i686.img  


指定了initramfs内存文件系统镜像文件的所在位置

### 15.3 系统修复模式

1. **单用户模式**



**单用户模式常见的错误修复 **

- 遗忘root密码 

- 修改系统默认运行级别


2. **光盘修复模式**


**重要系统文件丢失，导致系统无法启动** 
bash-4.1# chroot /mnt/sysimage 
#改变主目录 
sh-4.1# cd /root 
sh-4.1# rpm -qf /etc/inittab 
#查询下/etc/inittab文件属于哪个包。 
sh-4.1# mkdir /mnt/cdrom 
#建立挂载点 
sh-4.1# mount /dev/sr0 /mnt/cdrom 
#挂载光盘   
sh-4.1#  rpm2cpio/mnt/cdrom/Packages/initscripts-8.45.3-1.i386.rpm  \
  | cpio -idv ./etc/inittab 
#提取inittab文件到当前目录 
sh-4.1#  cp etc/inittab /etc/inittab 
#复制inittab文件到指定位置

3、**Linux的安全性**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593386671-2168c1b5-9d87-428c-85d2-08a861f0cff8.png#align=left&display=inline&height=294&margin=%5Bobject%20Object%5D&originHeight=416&originWidth=890&size=0&status=done&style=none&width=630)
### **
## 第十六章 备份与恢复

### 16.1 备份概述

1. Linux系统需要备份的数据 

- /root/目录： 

- /home/目录：

- /var/spool/mail/目录： 

- /etc/目录： 

- 其他目录： 


**安装服务的数据** 

- apache需要备份的数据 
   - 配置文件 

   - 网页主目录 

   - 日志文件 

   - mysql需要备份的数据

   - 源码包安装的mysql：/usr/local/mysql/data/ 

   - RPM包安装的mysql：/var/lib/mysql/


2. 备份策略 

- 完全备份：完全备份就是指把所有需要备份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录


**增量备份**
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593427919-fd48cdde-bca2-4b0e-8db5-07f20fd7440f.png#align=left&display=inline&height=580&margin=%5Bobject%20Object%5D&originHeight=580&originWidth=752&size=0&status=done&style=none&width=752)
**差异备份**


### 16.2 dump和restore命令

1. dump命令 


[root@localhost ~]# dump [选项] 备份之后的文件名 原文件或目录 
选项：  
-level： 就是我们说的0-9十个备份级别  
-f 文件名： 指定备份之后的文件名  
-u：  备份成功之后，把备份时间记录在/etc/dumpdates文件  
-v：  显示备份过程中更多的输出信息  
-j：  调用bzlib库压缩备份文件，其实就是把备份文件压缩  为.bz2格式，默认压缩等级是2  
-W： 显示允许被dump的分区的备份等级及备份时间  

备份分区 
dump -0uj -f /root/boot.bak.bz2 /boot/ 
#备份命令。先执行一次完全备份，并压缩和更新备份时间 
cat /etc/dumpdates 
#查看备份时间文件 
cp install.log /boot/ 
#复制日志文件到/boot分区 
dump -1uj -f /root/boot.bak1.bz2 /boot/ 
#增量备份/boot分区，并压缩 
dump –W 
#查询分区的备份时间及备份级别的

备份文件或目录
dump -0j -f /root/etc.dump.bz2 /etc/
#完全备份/etc/目录，只能使用0级别进行完全备份，而不再支持增量备份  

2. restore命令 


[root@localhost ~]# restore [模式选项] [选项]  
模式选项：restore命令常用的模式有以下四种，这四个模式不能混用。 
 	    -C：比较备份数据和实际数据的变化  
-i： 进入交互模式，手工选择需要恢复的文件。 
 	    -t： 查看模式，用于查看备份文件中拥有哪些数据。 
             -r： 还原模式，用于数据还原。 
选项： 
-f： 指定备份文件的文件名

## 附一章
**
### 0.0 微信二维码
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593427918-3068279a-6786-4914-a5a8-997bd8795698.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=430&originWidth=430&size=0&status=done&style=none&width=190)
**
### 1.1 su 命令报错
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593427925-c9fd9ed2-5f9b-4941-b427-256e2b761075.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=134&originWidth=538&size=0&status=done&style=none&width=538)
或者提示 su: Permission denied
原因：解开了/etc/pam.d/su中的
auth   required  pam_wheel.so use_uid  行注释
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593427947-1d2e6199-afc0-4b25-b95b-9acdcb9b9e4b.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&originHeight=466&originWidth=1054&size=0&status=done&style=none&width=1054)
解决方法：

1. 注释本行

1. 将需要的用户加入到wheel组

1. 命令：

```
usermod -G wheel username
```

示例：
roo用户：
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593427945-81d90b36-7cc2-4c21-bd4f-434cf8a1841c.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&originHeight=104&originWidth=674&size=0&status=done&style=none&width=674)
zookeeper 用户：
![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593428257-bcfc30d7-6992-493c-aef8-d47fd72a96e1.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1080&size=0&status=done&style=none&width=1080)
tips：箭头前面，root用户进行usermod -G wheel username操作。

将用户移出用户组：
```
gpasswd -d userName groupName
```

![](https://cdn.nlark.com/yuque/0/2021/png/1730795/1614593428068-081cd0c7-fc05-4b63-b79c-8dcae3af2e62.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&originHeight=226&originWidth=950&size=0&status=done&style=none&width=950)

### 1.2 连接sftp服务器命令
linux sftp远程连接命令
```
sftp -oPort=60001 root@192.168.0.254
```
使用-o选项来指定端口号。
　　-oPort=远程端口号
```
sftp> get /var/www/fuyatao/index.php /home/fuyatao/
```
这条语句将从远程主机的 /var/www/fuyatao/目录下将 index.php
　　下载到本地 /home/fuyatao/目录下。
```
sftp> put /home/fuyatao/downloads/Linuxgl.pdf 
/var/www/fuyatao/
```
这条语句将把本地 /home/fuyatao/downloads/目录下的 linuxgl.pdf文件上传至远程主机/var/www/fuyatao/ 目录下
### 1.3 Linux下Shell日期的格式
**常用的时间域如下：**
```
% Y 年（例如：1970，2018等） 
% m 月（01..12）
% d 一个月的第几天（01..31）
% H 小时（00..23）
% M 分（00..59）
% S 秒（00..59）
```

**使用不带参数的date命令获取当前时间日期。这样得到的一般是CST标准格式的时间。**
```
[alvin@VM_0_16_centos ~]$ date
Sat Nov  3 22:01:57 CST 2018
```
**获取特定以特定格式，命令为：date + ‘format’，注意这里大小写敏感。**
```
[alvin@VM_0_16_centos ~]$ date +'%Y-%m-%d'
2018-11-03
[alvin@VM_0_16_centos ~]$ date +'%Y/%m/%d %H:%M:%S'
2018/11/03 22:08:14
```

**获取昨天的日期。可在上述的命令里再加上-d选项。**
```
[alvin@VM_0_16_centos ~]$ date -d 'yesterday' +'%Y/%m/%d %H:%M:%S'
2018/11/02 22:24:31
或者
[alvin@VM_0_16_centos ~]$ date -d 'today -1 day' +'%Y-%m-%d'
2018-11-04
```

**获取当前时间的前一个小时**
```
[alvin@VM_0_16_centos ~]$ date -d 'today -1 hour' +'%Y%m%d%H'
2018110414
或者
[alvin@VM_0_16_centos ~]$ date +'%Y-%m-%d %H:%M:%S' -d '-1 hours'
2018-11-04 14:43:38
```

**获取指定日期前一天。这其实就是求相对时间。比如下面求国庆的前一天日期：**
```
[alvin@VM_0_16_centos ~]$ date -d '20181001 -1 day' +'%Y%m%d'
20180930
```

**将日期转换为时间戳时间戳**
```
[alvin@VM_0_16_centos ~]$ date -d "Nov  4 15:49:41 CST 2018" +%s
1541317781
```
**将时间戳转换回日期**
```
[alvin@VM_0_16_centos ~]$ date -d @1541317781
Sun Nov  4 15:49:41 CST 2018
```
**将时间戳转换为日期，并按特定格式显示**
```
[alvin@VM_0_16_centos ~]$ date -d @1541317781 +'%Y%m%d %H:%M:%S'
20181104 15:49:41
```

### 1.4 VM 中Linux时间恢复
[https://www.cnblogs.com/luchuangao/p/7795293.html](https://www.cnblogs.com/luchuangao/p/7795293.html)
### 

